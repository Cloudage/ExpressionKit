# ExpressionKit

A lightweight, interface-driven C++ expression parsing and evaluation library

## üöÄ Key Features

- **Interface-based variable read/write**: Flexible access to variables and functions via the Backend interface  
- **Pre-parsed AST execution**: Supports expression pre-compilation for efficient repeated execution
- **Type safety**: Strongly-typed Value system supporting numeric and boolean types
- **Complete operator support**: Full coverage of arithmetic, comparison, and logical operators
- **Exception-based error handling**: Clear error messages and robust exception mechanism
- **Zero dependencies**: Depends only on the C++ standard library

## ü§ñ AI-Generated Code Notice

**Important: The code in this project is primarily generated by AI tools (e.g., GitHub Copilot), under human guidance and review.**

The code follows modern C++ best practices and provides a clean, interface-based expression evaluation system.

## üìÑ License

This project is licensed under the MIT License ‚Äì see the license notice in the file headers.

## üõ†Ô∏è Quick Start

### Basic Usage

```cpp
#include "ExpressionKit.hpp"
using namespace ExpressionKit;

// Evaluate simple math expressions
auto result = ExprTK::Eval("2 + 3 * 4");  // Returns 14.0
std::cout << "Result: " << result.asNumber() << std::endl;

// Boolean expressions
auto boolResult = ExprTK::Eval("true && false");  // Returns false
std::cout << "Boolean result: " << boolResult.asBoolean() << std::endl;
```

### Using Backend for Variable Access

```cpp
#include "ExpressionKit.hpp"
#include <unordered_map>

class GameBackend : public ExpressionKit::Backend {
private:
    std::unordered_map<std::string, ExpressionKit::Value> variables;
    
public:
    GameBackend() {
        // Initialize game state
        variables["health"] = 100.0;
        variables["maxHealth"] = 100.0;
        variables["level"] = 5.0;
        variables["isAlive"] = true;
        variables["pos.x"] = 10.5;
        variables["pos.y"] = 20.3;
    }
    
    // Implement variable reading
    ExpressionKit::Value get(const std::string& name) override {
        auto it = variables.find(name);
        if (it == variables.end()) {
            throw ExpressionKit::ExprException("Variable not found: " + name);
        }
        return it->second;
    }
    
    // Implement variable writing (optional)
    void set(const std::string& name, const ExpressionKit::Value& value) override {
        variables[name] = value;
    }
    
    // Implement function calls
    ExpressionKit::Value call(const std::string& name, 
                             const std::vector<ExpressionKit::Value>& args) override {
        if (name == "max" && args.size() == 2) {
            double a = args[0].asNumber();
            double b = args[1].asNumber();
            return ExpressionKit::Value(std::max(a, b));
        }
        if (name == "sqrt" && args.size() == 1) {
            double val = args[0].asNumber();
            return ExpressionKit::Value(std::sqrt(val));
        }
        if (name == "distance" && args.size() == 4) {
            double x1 = args[0].asNumber(), y1 = args[1].asNumber();
            double x2 = args[2].asNumber(), y2 = args[3].asNumber();
            double dx = x2 - x1, dy = y2 - y1;
            return ExpressionKit::Value(std::sqrt(dx*dx + dy*dy));
        }
        throw ExpressionKit::ExprException("Unknown function: " + name);
    }
};

// Usage example
int main() {
    GameBackend backend;
    
    // Game logic expressions
    auto healthPercent = ExprTK::Eval("health / maxHealth", &backend);
    std::cout << "Health percentage: " << healthPercent.asNumber() << std::endl;
    
    // Complex condition checks
    auto needHealing = ExprTK::Eval("health < maxHealth * 0.5 && isAlive", &backend);
    std::cout << "Needs healing: " << (needHealing.asBoolean() ? "Yes" : "No") << std::endl;
    
    // Function calls
    auto playerPos = ExprTK::Eval("distance(pos.x, pos.y, 0, 0)", &backend);
    std::cout << "Distance from origin: " << playerPos.asNumber() << std::endl;
    
    return 0;
}
```

### High-Performance Execution with Pre-Parsed AST

A key feature of ExpressionKit is support for **pre-parsed ASTs**, allowing you to:
1. Parse expressions once
2. Execute them efficiently multiple times
3. Avoid repeated parsing overhead

```cpp
#include "ExpressionKit.hpp"

class HighPerformanceExample {
private:
    GameBackend backend;
    // Pre-compiled expression ASTs
    std::shared_ptr<ExpressionKit::ASTNode> healthCheckExpr;
    std::shared_ptr<ExpressionKit::ASTNode> damageCalcExpr;
    std::shared_ptr<ExpressionKit::ASTNode> levelUpExpr;
    
public:
    HighPerformanceExample() {
        // Pre-compile all expressions at startup
        healthCheckExpr = ExprTK::Parse("health > 0 && health <= maxHealth");
        damageCalcExpr = ExprTK::Parse("max(0, damage - armor) * (1.0 + level * 0.1)");
        levelUpExpr = ExprTK::Parse("exp >= level * 100");
    }
    
    // Efficient execution in game loop
    void gameLoop() {
        for (int frame = 0; frame < 10000; ++frame) {
            // Execute every frame without re-parsing
            bool playerAlive = healthCheckExpr->evaluate(&backend).asBoolean();
            
            if (playerAlive) {
                // Calculate damage (assuming damage and armor are set)
                double finalDamage = damageCalcExpr->evaluate(&backend).asNumber();
                
                // Check level up
                bool canLevelUp = levelUpExpr->evaluate(&backend).asBoolean();
                
                // Game logic...
            }
        }
    }
};
```

## üîß Supported Syntax

### Data Types
- **Numbers**: `42`, `3.14`, `-2.5`
- **Booleans**: `true`, `false`

### Operators (by precedence)

| Precedence | Operator | Description | Example |
|----------|---------|-------------|---------|
| 1 | `()` | Grouping | `(a + b) * c` |
| 2 | `!`, `not`, `-` | Unary operators | `!flag`, `not visible`, `-value` |
| 3 | `*`, `/` | Multiplication/Division | `a * b`, `x / y` |
| 4 | `+`, `-` | Addition/Subtraction | `a + b`, `x - y` |
| 5 | `<`, `>`, `<=`, `>=` | Relational comparison | `age >= 18`, `score < 100` |
| 6 | `==`, `!=` | Equality comparison | `name == "admin"`, `id != 0` |
| 7 | `xor` | Logical XOR | `a xor b` |
| 8 | `&&`, `and` | Logical AND | `a && b`, `x and y` |
| 9 | `\|\|`, `or` | Logical OR | `a \|\| b`, `x or y` |

### Variables and Functions
- **Variables**: `x`, `health`, `pos.x`, `player_name`
- **Function calls**: `max(a, b)`, `sqrt(x)`, `distance(x1, y1, x2, y2)`

## üèóÔ∏è Architecture Design

### Core Components

1. **Value** - Unified value type supporting numbers and booleans
2. **Backend** - Interface for variable and function access
3. **ASTNode** - Base class for abstract syntax tree nodes
4. **Parser** - Recursive descent parser
5. **ExprTK** - Main expression utility class

### Backend Interface

The Backend is a core design pattern in ExpressionKit, providing:

```cpp
class Backend {
public:
    virtual ~Backend() = default;
    
    // Required: Get variable value
    virtual Value get(const std::string& name) = 0;
    
    // Required: Call function
    virtual Value call(const std::string& name, 
                      const std::vector<Value>& args) = 0;
};
```

Advantages of this design:
- **Decoupling**: Separates expression parsing from concrete data sources
- **Flexibility**: Can integrate with any data source (database, config files, game state, etc.)
- **Testability**: Easy to create mock Backends for different scenarios
- **Performance**: Avoids string lookups, supports direct memory access

## üìä Performance Characteristics

### Benefits of Pre-Parsed AST

1. **Parse once, execute many times**
   ```cpp
   // Slow: parse every time
   for (int i = 0; i < 1000000; ++i) {
       auto result = ExprTK::Eval("complex_expression", &backend);
   }
   
   // Fast: pre-parse and reuse
   auto ast = ExprTK::Parse("complex_expression");
   for (int i = 0; i < 1000000; ++i) {
       auto result = ast->evaluate(&backend);
   }
   ```

2. **Memory efficiency**: AST nodes use shared_ptr for safety and efficiency
3. **Type safety**: Compile-time type checking and runtime validation

## üéØ Use Cases

- **Game engines**: Skill systems, AI condition checks, configuration expressions
- **Configuration systems**: Dynamic rules, conditional logic
- **Business rule engines**: Complex business logic expressions
- **Data processing**: Computed fields, filtering conditions
- **Scripting systems**: Embedded expression evaluation

## üîç Error Handling

ExpressionKit uses exceptions for error handling:

```cpp
try {
    auto result = ExprTK::Eval("invalid expression ++ --", &backend);
} catch (const ExpressionKit::ExprException& e) {
    std::cerr << "Expression error: " << e.what() << std::endl;
}
```

Common error types:
- Syntax errors: Invalid expression syntax
- Type errors: Mismatched operand types
- Runtime errors: Division by zero, undefined variables, etc.
- Function errors: Unknown functions, incorrect arguments

## üöß Compilation Requirements

- C++11 or later
- Supported compilers: GCC 4.8+, Clang 3.4+, MSVC 2015+
- Only depends on the C++ standard library

## üìö More Examples

See the `test.cpp` file for additional usage examples and test cases.

## ü§ù Contributing

As this project is primarily AI-generated, for suggested changes:
1. Provide specific feature requirements
2. Describe the desired API design
3. Include test cases

## üìû Support

For questions or suggestions, please open an Issue or review the code comments for implementation details.

---

# ExpressionKit

‰∏Ä‰∏™ËΩªÈáèÁ∫ß„ÄÅÊé•Âè£È©±Âä®ÁöÑC++Ë°®ËææÂºèËß£Êûê‰∏éÊ±ÇÂÄºÂ∫ì

## üöÄ ‰∏ªË¶ÅÁâπÊÄß

- **Êé•Âè£ÂåñÂèòÈáèËØªÂÜô**ÔºöÈÄöËøáBackendÊé•Âè£ÂÆûÁé∞ÂèòÈáèÂíåÂáΩÊï∞ÁöÑÁÅµÊ¥ªËÆøÈóÆ
- **È¢ÑËß£ÊûêASTÊâßË°å**ÔºöÊîØÊåÅË°®ËææÂºèÈ¢ÑÁºñËØëÔºåÂèØÈáçÂ§çÈ´òÊïàÊâßË°å
- **Á±ªÂûãÂÆâÂÖ®**ÔºöÂº∫Á±ªÂûãValueÁ≥ªÁªüÔºåÊîØÊåÅÊï∞ÂÄºÂíåÂ∏ÉÂ∞îÁ±ªÂûã
- **ÂÆåÊï¥ËøêÁÆóÁ¨¶ÊîØÊåÅ**ÔºöÁÆóÊúØ„ÄÅÊØîËæÉ„ÄÅÈÄªËæëËøêÁÆóÁ¨¶ÂÖ®Ë¶ÜÁõñ
- **ÂºÇÂ∏∏ÈîôËØØÂ§ÑÁêÜ**ÔºöÊ∏ÖÊô∞ÁöÑÈîôËØØ‰ø°ÊÅØÂíåÂºÇÂ∏∏Êú∫Âà∂
- **Èõ∂‰æùËµñ**Ôºö‰ªÖ‰æùËµñC++Ê†áÂáÜÂ∫ì

## ü§ñ AIÁîüÊàêÂ£∞Êòé

**ÈáçË¶ÅÊèêÁ§∫ÔºöÊú¨È°πÁõÆ‰ª£Á†Å‰∏ªË¶ÅÁî±AIÔºàGitHub CopilotÁ≠âAIÂ∑•ÂÖ∑ÔºâÁîüÊàêÔºåÁªèËøá‰∫∫Â∑•ÊåáÂØºÂíåÂÆ°Êü•„ÄÇ**

‰ª£Á†ÅÈÅµÂæ™Áé∞‰ª£C++ÊúÄ‰Ω≥ÂÆûË∑µÔºåÊèê‰æõ‰∫Ü‰∏Ä‰∏™Ê∏ÖÊ¥Å„ÄÅÂü∫‰∫éÊé•Âè£ÁöÑË°®ËææÂºèÊ±ÇÂÄºÁ≥ªÁªü„ÄÇ

## üìÑ ËÆ∏ÂèØËØÅ

Êú¨È°πÁõÆÈááÁî®MITËÆ∏ÂèØËØÅ - ËØ¶ËßÅÊñá‰ª∂Â§¥ÈÉ®ÁöÑËÆ∏ÂèØËØÅÂ£∞Êòé„ÄÇ

## üõ†Ô∏è Âø´ÈÄüÂºÄÂßã

### Âü∫Êú¨Áî®Ê≥ï

```cpp
#include "ExpressionKit.hpp"
using namespace ExpressionKit;

// ÁÆÄÂçïÁöÑÊï∞Â≠¶Ë°®ËææÂºèÊ±ÇÂÄº
auto result = ExprTK::Eval("2 + 3 * 4");  // ËøîÂõû 14.0
std::cout << "ÁªìÊûú: " << result.asNumber() << std::endl;

// Â∏ÉÂ∞îË°®ËææÂºè
auto boolResult = ExprTK::Eval("true && false");  // ËøîÂõû false
std::cout << "Â∏ÉÂ∞îÁªìÊûú: " << boolResult.asBoolean() << std::endl;
```

### ‰ΩøÁî®BackendÂÆûÁé∞ÂèòÈáèËÆøÈóÆ

```cpp
#include "ExpressionKit.hpp"
#include <unordered_map>

class GameBackend : public ExpressionKit::Backend {
private:
    std::unordered_map<std::string, ExpressionKit::Value> variables;
    
public:
    GameBackend() {
        // ÂàùÂßãÂåñÊ∏∏ÊàèÁä∂ÊÄÅ
        variables["health"] = 100.0;
        variables["maxHealth"] = 100.0;
        variables["level"] = 5.0;
        variables["isAlive"] = true;
        variables["pos.x"] = 10.5;
        variables["pos.y"] = 20.3;
    }
    
    // ÂÆûÁé∞ÂèòÈáèËØªÂèñ
    ExpressionKit::Value get(const std::string& name) override {
        auto it = variables.find(name);
        if (it == variables.end()) {
            throw ExpressionKit::ExprException("Êú™ÊâæÂà∞ÂèòÈáè: " + name);
        }
        return it->second;
    }
    
    // ÂÆûÁé∞ÂèòÈáèÂÜôÂÖ•ÔºàÂèØÈÄâÔºâ
    void set(const std::string& name, const ExpressionKit::Value& value) override {
        variables[name] = value;
    }
    
    // ÂÆûÁé∞ÂáΩÊï∞Ë∞ÉÁî®
    ExpressionKit::Value call(const std::string& name, 
                             const std::vector<ExpressionKit::Value>& args) override {
        if (name == "max" && args.size() == 2) {
            double a = args[0].asNumber();
            double b = args[1].asNumber();
            return ExpressionKit::Value(std::max(a, b));
        }
        if (name == "sqrt" && args.size() == 1) {
            double val = args[0].asNumber();
            return ExpressionKit::Value(std::sqrt(val));
        }
        if (name == "distance" && args.size() == 4) {
            double x1 = args[0].asNumber(), y1 = args[1].asNumber();
            double x2 = args[2].asNumber(), y2 = args[3].asNumber();
            double dx = x2 - x1, dy = y2 - y1;
            return ExpressionKit::Value(std::sqrt(dx*dx + dy*dy));
        }
        throw ExpressionKit::ExprException("Êú™Áü•ÂáΩÊï∞: " + name);
    }
};

// ‰ΩøÁî®Á§∫‰æã
int main() {
    GameBackend backend;
    
    // Ê∏∏ÊàèÈÄªËæëË°®ËææÂºè
    auto healthPercent = ExprTK::Eval("health / maxHealth", &backend);
    std::cout << "ÁîüÂëΩÂÄºÁôæÂàÜÊØî: " << healthPercent.asNumber() << std::endl;
    
    // Â§çÊùÇÊù°‰ª∂Âà§Êñ≠
    auto needHealing = ExprTK::Eval("health < maxHealth * 0.5 && isAlive", &backend);
    std::cout << "ÈúÄË¶ÅÊ≤ªÁñó: " << (needHealing.asBoolean() ? "ÊòØ" : "Âê¶") << std::endl;
    
    // ÂáΩÊï∞Ë∞ÉÁî®
    auto playerPos = ExprTK::Eval("distance(pos.x, pos.y, 0, 0)", &backend);
    std::cout << "Ë∑ùÁ¶ªÂéüÁÇπ: " << playerPos.asNumber() << std::endl;
    
    return 0;
}
```

### È¢ÑËß£ÊûêASTÈ´òÊÄßËÉΩÊâßË°å

ExpressionKitÁöÑ‰∏Ä‰∏™ÂÖ≥ÈîÆÁâπÊÄßÊòØÊîØÊåÅ**È¢ÑËß£ÊûêAST**ÔºåËøôÂÖÅËÆ∏‰Ω†Ôºö
1. ‰∏ÄÊ¨°Ëß£ÊûêË°®ËææÂºè
2. Â§öÊ¨°È´òÊïàÊâßË°å
3. ÈÅøÂÖçÈáçÂ§çËß£ÊûêÂºÄÈîÄ

```cpp
#include "ExpressionKit.hpp"

class HighPerformanceExample {
private:
    GameBackend backend;
    // È¢ÑÁºñËØëÁöÑË°®ËææÂºèAST
    std::shared_ptr<ExpressionKit::ASTNode> healthCheckExpr;
    std::shared_ptr<ExpressionKit::ASTNode> damageCalcExpr;
    std::shared_ptr<ExpressionKit::ASTNode> levelUpExpr;
    
public:
    HighPerformanceExample() {
        // Ê∏∏ÊàèÂêØÂä®Êó∂È¢ÑÁºñËØëÊâÄÊúâË°®ËææÂºè
        healthCheckExpr = ExprTK::Parse("health > 0 && health <= maxHealth");
        damageCalcExpr = ExprTK::Parse("max(0, damage - armor) * (1.0 + level * 0.1)");
        levelUpExpr = ExprTK::Parse("exp >= level * 100");
    }
    
    // Ê∏∏ÊàèÂæ™ÁéØ‰∏≠È´òÊïàÊâßË°å
    void gameLoop() {
        for (int frame = 0; frame < 10000; ++frame) {
            // ÊØèÂ∏ßÈÉΩÊâßË°åÔºå‰ΩÜ‰∏çÈúÄË¶ÅÈáçÊñ∞Ëß£Êûê
            bool playerAlive = healthCheckExpr->evaluate(&backend).asBoolean();
            
            if (playerAlive) {
                // ËÆ°ÁÆó‰º§ÂÆ≥ÔºàÂÅáËÆæËÆæÁΩÆ‰∫ÜdamageÂíåarmorÂèòÈáèÔºâ
                double finalDamage = damageCalcExpr->evaluate(&backend).asNumber();
                
                // Ê£ÄÊü•ÂçáÁ∫ß
                bool canLevelUp = levelUpExpr->evaluate(&backend).asBoolean();
                
                // Ê∏∏ÊàèÈÄªËæë...
            }
        }
    }
};
```

## üîß ÊîØÊåÅÁöÑËØ≠Ê≥ï

### Êï∞ÊçÆÁ±ªÂûã
- **Êï∞ÂÄº**: `42`, `3.14`, `-2.5`
- **Â∏ÉÂ∞îÂÄº**: `true`, `false`

### ËøêÁÆóÁ¨¶ÔºàÊåâ‰ºòÂÖàÁ∫ßÊéíÂ∫èÔºâ

| ‰ºòÂÖàÁ∫ß | ËøêÁÆóÁ¨¶ | ËØ¥Êòé | Á§∫‰æã |
|--------|--------|------|------|
| 1 | `()` | Êã¨Âè∑ÂàÜÁªÑ | `(a + b) * c` |
| 2 | `!`, `not`, `-` | ‰∏ÄÂÖÉËøêÁÆóÁ¨¶ | `!flag`, `not visible`, `-value` |
| 3 | `*`, `/` | ‰πòÈô§ËøêÁÆó | `a * b`, `x / y` |
| 4 | `+`, `-` | Âä†ÂáèËøêÁÆó | `a + b`, `x - y` |
| 5 | `<`, `>`, `<=`, `>=` | ÂÖ≥Á≥ªÊØîËæÉ | `age >= 18`, `score < 100` |
| 6 | `==`, `!=` | Áõ∏Á≠âÊØîËæÉ | `name == "admin"`, `id != 0` |
| 7 | `xor` | ÈÄªËæëÂºÇÊàñ | `a xor b` |
| 8 | `&&`, `and` | ÈÄªËæë‰∏é | `a && b`, `x and y` |
| 9 | `\|\|`, `or` | ÈÄªËæëÊàñ | `a \|\| b`, `x or y` |

### ÂèòÈáèÂíåÂáΩÊï∞
- **ÂèòÈáè**: `x`, `health`, `pos.x`, `player_name`
- **ÂáΩÊï∞Ë∞ÉÁî®**: `max(a, b)`, `sqrt(x)`, `distance(x1, y1, x2, y2)`

## üèóÔ∏è Êû∂ÊûÑËÆæËÆ°

### Ê†∏ÂøÉÁªÑ‰ª∂

1. **Value** - Áªü‰∏ÄÁöÑÂÄºÁ±ªÂûãÔºåÊîØÊåÅÊï∞ÂÄºÂíåÂ∏ÉÂ∞î
2. **Backend** - ÂèòÈáèÂíåÂáΩÊï∞ËÆøÈóÆÊé•Âè£
3. **ASTNode** - ÊäΩË±°ËØ≠Ê≥ïÊ†ëËäÇÁÇπÂü∫Á±ª
4. **Parser** - ÈÄíÂΩí‰∏ãÈôçËß£ÊûêÂô®
5. **ExprTK** - ‰∏ªË¶ÅÁöÑË°®ËææÂºèÂ∑•ÂÖ∑Á±ª

### BackendÊé•Âè£

BackendÊòØExpressionKitÁöÑÊ†∏ÂøÉËÆæËÆ°Ê®°ÂºèÔºåÂÆÉÊèê‰æõ‰∫ÜÔºö

```cpp
class Backend {
public:
    virtual ~Backend() = default;
    
    // ÂøÖÈ°ªÂÆûÁé∞ÔºöËé∑ÂèñÂèòÈáèÂÄº
    virtual Value get(const std::string& name) = 0;
    
    // ÂøÖÈ°ªÂÆûÁé∞ÔºöË∞ÉÁî®ÂáΩÊï∞
    virtual Value call(const std::string& name, 
                      const std::vector<Value>& args) = 0;
};
```

ËøôÁßçËÆæËÆ°ÁöÑ‰ºòÂäøÔºö
- **Ëß£ËÄ¶**ÔºöË°®ËææÂºèËß£Êûê‰∏éÂÖ∑‰ΩìÊï∞ÊçÆÊ∫êÂàÜÁ¶ª
- **ÁÅµÊ¥ª**ÔºöÂèØ‰ª•Êé•ÂÖ•‰ªª‰ΩïÊï∞ÊçÆÊ∫êÔºàÊï∞ÊçÆÂ∫ì„ÄÅÈÖçÁΩÆÊñá‰ª∂„ÄÅÊ∏∏ÊàèÁä∂ÊÄÅÁ≠âÔºâ
- **ÂèØÊµãËØï**ÔºöÊòì‰∫é‰∏∫‰∏çÂêåÂú∫ÊôØÂàõÂª∫Mock Backend
- **È´òÊÄßËÉΩ**ÔºöÈÅøÂÖçÂ≠óÁ¨¶‰∏≤Êü•ÊâæÔºåÊîØÊåÅÁõ¥Êé•ÂÜÖÂ≠òËÆøÈóÆ

## üìä ÊÄßËÉΩÁâπÊÄß

### È¢ÑËß£ÊûêASTÁöÑ‰ºòÂäø

1. **‰∏ÄÊ¨°Ëß£ÊûêÔºåÂ§öÊ¨°ÊâßË°å**
   ```cpp
   // ÊÖ¢ÔºöÊØèÊ¨°ÈÉΩËß£Êûê
   for (int i = 0; i < 1000000; ++i) {
       auto result = ExprTK::Eval("complex_expression", &backend);
   }
   
   // Âø´ÔºöÈ¢ÑËß£ÊûêÂêéÈáçÂ§çÊâßË°å
   auto ast = ExprTK::Parse("complex_expression");
   for (int i = 0; i < 1000000; ++i) {
       auto result = ast->evaluate(&backend);
   }
   ```

2. **ÂÜÖÂ≠òÊïàÁéá**: ASTËäÇÁÇπ‰ΩøÁî®shared_ptrÔºåÂÆâÂÖ®‰∏îÈ´òÊïà
3. **Á±ªÂûãÂÆâÂÖ®**: ÁºñËØëÊó∂Á±ªÂûãÊ£ÄÊü•ÔºåËøêË°åÊó∂Á±ªÂûãÈ™åËØÅ

## üéØ ‰ΩøÁî®Âú∫ÊôØ

- **Ê∏∏ÊàèÂºïÊìé**: ÊäÄËÉΩÁ≥ªÁªü„ÄÅAIÊù°‰ª∂Âà§Êñ≠„ÄÅÈÖçÁΩÆË°®ËææÂºè
- **ÈÖçÁΩÆÁ≥ªÁªü**: Âä®ÊÄÅÈÖçÁΩÆËßÑÂàô„ÄÅÊù°‰ª∂Âà§Êñ≠
- **‰∏öÂä°ËßÑÂàôÂºïÊìé**: Â§çÊùÇ‰∏öÂä°ÈÄªËæëË°®ËææÂºè
- **Êï∞ÊçÆÂ§ÑÁêÜ**: ËÆ°ÁÆóÂ≠óÊÆµ„ÄÅËøáÊª§Êù°‰ª∂
- **ËÑöÊú¨Á≥ªÁªü**: ÂµåÂÖ•ÂºèË°®ËææÂºèÊ±ÇÂÄº

## üîç ÈîôËØØÂ§ÑÁêÜ

ExpressionKit‰ΩøÁî®ÂºÇÂ∏∏Êú∫Âà∂Â§ÑÁêÜÈîôËØØÔºö

```cpp
try {
    auto result = ExprTK::Eval("invalid expression ++ --", &backend);
} catch (const ExpressionKit::ExprException& e) {
    std::cerr << "Ë°®ËææÂºèÈîôËØØ: " << e.what() << std::endl;
}
```

Â∏∏ËßÅÈîôËØØÁ±ªÂûãÔºö
- ËØ≠Ê≥ïÈîôËØØÔºöÊó†ÊïàÁöÑË°®ËææÂºèËØ≠Ê≥ï
- Á±ªÂûãÈîôËØØÔºöÁ±ªÂûã‰∏çÂåπÈÖçÁöÑÊìç‰Ωú
- ËøêË°åÊó∂ÈîôËØØÔºöÈô§Èõ∂„ÄÅÊú™ÂÆö‰πâÂèòÈáèÁ≠â
- ÂáΩÊï∞ÈîôËØØÔºöÊú™Áü•ÂáΩÊï∞„ÄÅÂèÇÊï∞‰∏çÂåπÈÖç

## üöß ÁºñËØëË¶ÅÊ±Ç

- C++11 ÊàñÊõ¥È´òÁâàÊú¨
- ÊîØÊåÅÁöÑÁºñËØëÂô®ÔºöGCC 4.8+, Clang 3.4+, MSVC 2015+
- ‰ªÖ‰æùËµñC++Ê†áÂáÜÂ∫ì

## üìö Êõ¥Â§öÁ§∫‰æã

Êü•Áúã `test.cpp` Êñá‰ª∂‰ª•Ëé∑ÂèñÊõ¥Â§ö‰ΩøÁî®Á§∫‰æãÂíåÊµãËØïÁî®‰æã„ÄÇ

## ü§ù Ë¥°ÁåÆ

Áî±‰∫éÊú¨È°πÁõÆ‰∏ªË¶ÅÁî±AIÁîüÊàêÔºåÂ¶ÇÈúÄ‰øÆÊîπÂª∫ËÆÆÔºö
1. ÊèêÂá∫ÂÖ∑‰ΩìÁöÑÂäüËÉΩÈúÄÊ±Ç
2. ÊèèËø∞È¢ÑÊúüÁöÑAPIËÆæËÆ°
3. Êèê‰æõÊµãËØïÁî®‰æã

## üìû ÊîØÊåÅ

Â¶ÇÊúâÈóÆÈ¢òÊàñÂª∫ËÆÆÔºåËØ∑ÂàõÂª∫IssueÊàñÊü•Áúã‰ª£Á†ÅÊ≥®Èáä‰ª•‰∫ÜËß£ÂÆûÁé∞ÁªÜËäÇ„ÄÇ
