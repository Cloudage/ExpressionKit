# ExpressionKit

A lightweight, interface-driven C++ expression parsing and evaluation library with Swift support and token sequence analysis

## üöÄ Key Features

- **Interface-based variable read/write**: Flexible access to variables and functions via the IEnvironment interface  
- **Pre-parsed AST execution**: Supports expression pre-compilation for efficient repeated execution
- **Token sequence analysis**: Optional token collection for syntax highlighting and advanced features
- **Type safety**: Strongly-typed Value system supporting numeric and boolean types
- **Complete operator support**: Full coverage of arithmetic, comparison, and logical operators
- **Exception-based error handling**: Clear error messages and robust exception mechanism
- **Zero dependencies**: Depends only on the C++ standard library
- **Swift Support**: Clean Swift API with Swift Package Manager integration

## üß™ Test Status

[![Test Status Check](https://github.com/Cloudage/ExpressionKit/actions/workflows/test-status-check.yml/badge.svg)](https://github.com/Cloudage/ExpressionKit/actions/workflows/test-status-check.yml)

### Automated Testing

This repository uses automated testing with GitHub Actions to ensure code quality and reliability:

- **C++ Core Library**: Comprehensive testing using Catch2 framework
- **Swift Wrapper**: Testing via XCTest framework with Swift Package Manager

**View Latest Test Results**: Click the badge above or visit the [Actions tab](https://github.com/Cloudage/ExpressionKit/actions/workflows/test-status-check.yml) to see detailed test results, including test counts, assertions, and execution summaries.

### Running Tests Locally

```bash
# Run all tests
./scripts/run_all_tests.sh

# Run individual test suites
./scripts/run_cpp_tests.sh      # C++ tests only
./scripts/run_swift_tests.sh    # Swift tests only
```
## ü§ñ AI-Generated Code Notice

**Important: The code in this project is primarily generated by AI tools (e.g., GitHub Copilot), under human guidance and review.**

The code follows modern C++ best practices and provides a clean, interface-based expression evaluation system.

## üõ†Ô∏è Setup & Installation

### For Swift Projects (Recommended)

ExpressionKit can be easily integrated into Swift projects using **Swift Package Manager**:

#### Option 1: Xcode Integration
1. Open your Xcode project
2. Go to **File** ‚Üí **Add Package Dependencies**
3. Enter repository URL: `https://github.com/Cloudage/ExpressionKit.git`
4. Select version (from `1.0.0`)

#### Option 2: Package.swift
Add to your `Package.swift` dependencies:

```swift
dependencies: [
    .package(url: "https://github.com/Cloudage/ExpressionKit.git", from: "1.0.0")
]
```

Then import and use:

```swift
import ExpressionKit

// Direct evaluation
let result = try Expression.eval("2 + 3 * 4")  // 14.0

// Parse once, execute many times (high performance)
let expression = try Expression.parse("(a + b) * c - 1")
for _ in 0..<10000 {
    let result = try expression.eval()  // Very fast!
}
```

**üìñ For complete Swift documentation, see [SWIFT_USAGE.md](SWIFT_USAGE.md)**

### For C++ Projects

For C++ projects, simply **copy the single header file** `ExpressionKit.hpp` to your project:

1. **Download**: Copy `ExpressionKit.hpp` from this repository
2. **Include**: Add `#include "ExpressionKit.hpp"` to your C++ files
3. **Compile**: Requires C++11 or later, no external dependencies

```cpp
#include "ExpressionKit.hpp"
using namespace ExpressionKit;

// Evaluate simple math expressions
auto result = Expression::Eval("2 + 3 * 4");  // Returns 14.0
std::cout << "Result: " << result.asNumber() << std::endl;

// Boolean expressions
auto boolResult = Expression::Eval("true && false");  // Returns false
std::cout << "Boolean result: " << boolResult.asBoolean() << std::endl;

// Token sequence collection for syntax highlighting
std::vector<Token> tokens;
auto resultWithTokens = Expression::Eval("2 + 3 * max(4, 5)", nullptr, &tokens);
std::cout << "Result: " << resultWithTokens.asNumber() << std::endl;
for (const auto& token : tokens) {
    std::cout << "Token: " << (int)token.type << " '" << token.text 
              << "' at " << token.start << ":" << token.length << std::endl;
}
```

## üìä Quick Comparison

| Feature | Swift | C++ |
|---------|-------|-----|
| **Setup** | Swift Package Manager | Copy single .hpp file |
| **Dependencies** | None (handled by SPM) | None (header-only) |
| **Integration** | `import ExpressionKit` | `#include "ExpressionKit.hpp"` |
| **API** | `Expression.eval()` | `Expression::Eval()` |
| **Performance** | ‚úÖ Full performance | ‚úÖ Full performance |
| **Features** | ‚úÖ All core features | ‚úÖ All features + Environment |

### Which Version Should I Use?

- **üéØ Swift Projects**: Use Swift Package Manager integration for clean, type-safe API
- **üîß C++ Projects**: Copy `ExpressionKit.hpp` for zero-dependency, header-only solution  
- **üèóÔ∏è Mixed Projects**: Both can coexist - same expression syntax and behavior

## üé® Token Sequence Analysis

ExpressionKit provides powerful token sequence analysis capabilities for syntax highlighting, IDE integration, and advanced expression analysis.

### Token Types

The library identifies the following token types during parsing:

| Token Type | Description | Examples |
|------------|-------------|----------|
| `NUMBER` | Numeric literals | `42`, `3.14`, `-2.5` |
| `BOOLEAN` | Boolean literals | `true`, `false` |
| `IDENTIFIER` | Variables and function names | `x`, `pos.x`, `sqrt`, `player_health` |
| `OPERATOR` | All operators | `+`, `-`, `*`, `/`, `==`, `!=`, `&&`, `\|\|`, `!` |
| `PARENTHESIS` | Grouping symbols | `(`, `)` |
| `COMMA` | Function argument separator | `,` |
| `WHITESPACE` | Spaces and tabs | ` `, `\t` |
| `UNKNOWN` | Unrecognized tokens | (used for error handling) |

### C++ Token Collection

```cpp
#include "ExpressionKit.hpp"
using namespace ExpressionKit;

// Collect tokens during evaluation
std::vector<Token> tokens;
auto result = Expression::Eval("max(x + 5, y * 2)", &environment, &tokens);

// Process tokens for syntax highlighting
for (const auto& token : tokens) {
    std::cout << "Type: " << (int)token.type 
              << " Text: '" << token.text << "'" 
              << " Position: " << token.start << "-" << (token.start + token.length)
              << std::endl;
}

// Alternative: Parse with tokens for pre-compilation
std::vector<Token> parseTokens;
auto ast = Expression::Parse("complex_expression", &parseTokens);
// parseTokens now contains all tokens for syntax highlighting
auto result = ast->evaluate(&environment);
```

### Swift Token Collection

```swift
import ExpressionKit

// Evaluate with token collection
let (value, tokens) = try Expression.eval("max(x + 5, y * 2)", collectTokens: true)
print("Result: \(value)")

if let tokens = tokens {
    for token in tokens {
        print("Type: \(token.type), Text: '\(token.text)', Position: \(token.start)-\(token.start + token.length)")
    }
}

// Parse with token collection for pre-compilation
let (expression, parseTokens) = try Expression.parse("complex_expression", collectTokens: true)
// parseTokens contains all tokens for analysis
let result = try expression.eval()
```

### Use Cases for Token Sequences

- **üé® Syntax Highlighting**: Color-code different token types in code editors
- **üîç Error Reporting**: Precise error location and context information
- **‚úÖ Expression Validation**: Check syntax before evaluation
- **ü§ñ Auto-completion**: Suggest variables and functions based on context
- **üìù Code Formatting**: Pretty-print expressions with proper spacing
- **üîß Static Analysis**: Analyze expressions without execution
- **üèóÔ∏è IDE Integration**: Build advanced expression editing tools
- **üìä Expression Metrics**: Count operators, complexity analysis

### Performance Impact

Token collection has minimal performance overhead:

```cpp
// Benchmark: 1M evaluations of "2 + 3 * 4"
// Without tokens: ~50ms
// With tokens:    ~55ms
// Overhead:       ~10%
```

The overhead is primarily from string allocation for token text. For performance-critical applications, collect tokens only when needed (e.g., during development or for user-facing editors).

## üöÄ Examples

### Swift Examples

```swift
import ExpressionKit

// Basic arithmetic
let result1 = try Expression.eval("2 + 3 * 4")  // 14.0

// Boolean logic
let result2 = try Expression.eval("true && (5 > 3)")  // true

// Complex expressions
let result3 = try Expression.eval("(2 + 3) * 4 - 1")  // 19.0

// Parse once, execute many times for high performance
let expression = try Expression.parse("(a + b) * c - 1")
for _ in 0..<10000 {
    let result = try expression.eval()  // Very fast repeated execution
}

// Token sequence collection for syntax highlighting
let (value, tokens) = try Expression.eval("2 + 3 * max(4, 5)", collectTokens: true)
print("Result: \(value)")
if let tokens = tokens {
    for token in tokens {
        print("Token: \(token.type) '\(token.text)' at \(token.start):\(token.length)")
    }
}

// Error handling
do {
    let result = try Expression.eval("1 / 0")
} catch let error as ExpressionError {
    print("Expression error: \(error.localizedDescription)")
}
```

### Using IEnvironment for Variable Access (C++)

```cpp
#include "ExpressionKit.hpp"
#include <unordered_map>

class GameEnvironment : public ExpressionKit::IEnvironment {
private:
    std::unordered_map<std::string, ExpressionKit::Value> variables;
    
public:
    GameEnvironment() {
        // Initialize game state
        variables["health"] = 100.0;
        variables["maxHealth"] = 100.0;
        variables["level"] = 5.0;
        variables["isAlive"] = true;
        variables["pos.x"] = 10.5;
        variables["pos.y"] = 20.3;
    }
    
    // Implement variable reading
    ExpressionKit::Value Get(const std::string& name) override {
        auto it = variables.find(name);
        if (it == variables.end()) {
            throw ExpressionKit::ExprException("Variable not found: " + name);
        }
        return it->second;
    }
    
    // Implement function calls
    ExpressionKit::Value Call(const std::string& name, 
                             const std::vector<ExpressionKit::Value>& args) override {
        // Try standard mathematical functions first
        ExpressionKit::Value result;
        if (Expression::CallStandardFunctions(name, args, result)) {
            return result;
        }
        
        // Custom functions
        if (name == "distance" && args.size() == 4) {
            double x1 = args[0].asNumber(), y1 = args[1].asNumber();
            double x2 = args[2].asNumber(), y2 = args[3].asNumber();
            double dx = x2 - x1, dy = y2 - y1;
            return ExpressionKit::Value(std::sqrt(dx*dx + dy*dy));
        }
        throw ExpressionKit::ExprException("Unknown function: " + name);
    }
};

// Usage example
int main() {
    GameEnvironment environment;
    
    // Game logic expressions
    auto healthPercent = Expression::Eval("health / maxHealth", &environment);
    std::cout << "Health percentage: " << healthPercent.asNumber() << std::endl;
    
    // Complex condition checks
    auto needHealing = Expression::Eval("health < maxHealth * 0.5 && isAlive", &environment);
    std::cout << "Needs healing: " << (needHealing.asBoolean() ? "Yes" : "No") << std::endl;
    
    // Function calls
    auto playerPos = Expression::Eval("distance(pos.x, pos.y, 0, 0)", &environment);
    std::cout << "Distance from origin: " << playerPos.asNumber() << std::endl;
    
    return 0;
}
```

### High-Performance Execution with Pre-Parsed AST (C++)

A key feature of ExpressionKit is support for **pre-parsed ASTs**, allowing you to:
1. Parse expressions once
2. Execute them efficiently multiple times
3. Avoid repeated parsing overhead

```cpp
#include "ExpressionKit.hpp"

class HighPerformanceExample {
private:
    GameEnvironment environment;
    // Pre-compiled expression ASTs
    std::shared_ptr<ExpressionKit::ASTNode> healthCheckExpr;
    std::shared_ptr<ExpressionKit::ASTNode> damageCalcExpr;
    std::shared_ptr<ExpressionKit::ASTNode> levelUpExpr;
    
public:
    HighPerformanceExample() {
        // Pre-compile all expressions at startup
        healthCheckExpr = Expression::Parse("health > 0 && health <= maxHealth");
        damageCalcExpr = Expression::Parse("max(0, damage - armor) * (1.0 + level * 0.1)");
        levelUpExpr = Expression::Parse("exp >= level * 100");
    }
    
    // Efficient execution in game loop
    void gameLoop() {
        for (int frame = 0; frame < 10000; ++frame) {
            // Execute every frame without re-parsing
            bool playerAlive = healthCheckExpr->evaluate(&environment).asBoolean();
            
            if (playerAlive) {
                // Calculate damage (assuming damage and armor are set)
                double finalDamage = damageCalcExpr->evaluate(&environment).asNumber();
                
                // Check level up
                bool canLevelUp = levelUpExpr->evaluate(&environment).asBoolean();
                
                // Game logic...
            }
        }
    }
};
```

## üìÑ License

This project is licensed under the MIT License ‚Äì see the license notice in the file headers.

## üîß Supported Syntax (Both C++ and Swift)

### Data Types
- **Numbers**: `42`, `3.14`, `-2.5`
- **Booleans**: `true`, `false`

### Operators (by precedence)

| Precedence | Operator | Description | Example |
|----------|---------|-------------|---------|
| 1 | `()` | Grouping | `(a + b) * c` |
| 2 | `!`, `not`, `-` | Unary operators | `!flag`, `not visible`, `-value` |
| 3 | `*`, `/` | Multiplication/Division | `a * b`, `x / y` |
| 4 | `+`, `-` | Addition/Subtraction | `a + b`, `x - y` |
| 5 | `<`, `>`, `<=`, `>=` | Relational comparison | `age >= 18`, `score < 100` |
| 6 | `==`, `!=` | Equality comparison | `name == "admin"`, `id != 0` |
| 7 | `xor` | Logical XOR | `a xor b` |
| 8 | `&&`, `and` | Logical AND | `a && b`, `x and y` |
| 9 | `\|\|`, `or` | Logical OR | `a \|\| b`, `x or y` |

### Variables and Functions
- **Variables**: `x`, `health`, `pos.x`, `player_name`
- **Function calls**: `max(a, b)`, `sqrt(x)`, `distance(x1, y1, x2, y2)`

### Built-in Mathematical Functions
ExpressionKit provides a comprehensive set of standard mathematical functions through the `CallStandardFunctions` method:

| Function | Description | Example |
|----------|-------------|---------|
| `min(a, b)` | Returns the smaller of two numbers | `min(10, 5)` ‚Üí `5` |
| `max(a, b)` | Returns the larger of two numbers | `max(10, 5)` ‚Üí `10` |
| `sqrt(x)` | Returns the square root of x | `sqrt(16)` ‚Üí `4` |
| `sin(x)` | Returns the sine of x (radians) | `sin(3.14159/2)` ‚Üí `1` |
| `cos(x)` | Returns the cosine of x (radians) | `cos(0)` ‚Üí `1` |
| `tan(x)` | Returns the tangent of x (radians) | `tan(0)` ‚Üí `0` |
| `abs(x)` | Returns the absolute value of x | `abs(-5)` ‚Üí `5` |
| `pow(x, y)` | Returns x raised to the power of y | `pow(2, 3)` ‚Üí `8` |
| `log(x)` | Returns the natural logarithm of x | `log(2.718)` ‚Üí `‚âà1` |
| `exp(x)` | Returns e raised to the power of x | `exp(1)` ‚Üí `‚âà2.718` |
| `floor(x)` | Returns the largest integer ‚â§ x | `floor(3.7)` ‚Üí `3` |
| `ceil(x)` | Returns the smallest integer ‚â• x | `ceil(3.2)` ‚Üí `4` |
| `round(x)` | Returns x rounded to nearest integer | `round(3.6)` ‚Üí `4` |

These functions can be used in IEnvironment implementations to provide mathematical capabilities:

```cpp
class MathEnvironment : public ExpressionKit::IEnvironment {
public:
    ExpressionKit::Value Call(const std::string& name, 
                             const std::vector<ExpressionKit::Value>& args) override {
        ExpressionKit::Value result;
        
        // Try standard mathematical functions first
        if (Expression::CallStandardFunctions(name, args, result)) {
            return result;
        }
        
        // Custom functions...
        throw ExpressionKit::ExprException("Unknown function: " + name);
    }
    
    // ... other methods
};
```
## üèóÔ∏è Architecture Design

### Core Components

1. **Value** - Unified value type supporting numbers and booleans
2. **IEnvironment** - Interface for variable and function access
3. **ASTNode** - Base class for abstract syntax tree nodes
4. **Parser** - Recursive descent parser
5. **ExpressionKit** - Main expression utility class
6. **ExpressionKitBridge** - C bridge for Swift integration (located in `Sources/ExpressionKitBridge/`)

### Swift Integration Architecture

ExpressionKit provides seamless Swift integration through a layered architecture:

1. **ExpressionKit.hpp** - Core C++ header-only library
2. **ExpressionKitBridge** - C interface bridge that wraps the C++ code for Swift compatibility
3. **ExpressionKit (Swift)** - Swift wrapper providing idiomatic Swift APIs

```
Swift Code
    ‚Üì
ExpressionKit (Swift Package)
    ‚Üì
ExpressionKitBridge (C Interface)
    ‚Üì
ExpressionKit.hpp (C++ Core)
```

This design ensures:
- **Clean separation**: Each layer has a clear responsibility
- **Swift safety**: The bridge handles C++/Swift interop complexities
- **Performance**: Minimal overhead between layers
- **Maintainability**: Changes to C++ core don't affect Swift API

### IEnvironment Interface

The IEnvironment is a core design pattern in ExpressionKit, providing:

```cpp
class IEnvironment {
public:
    virtual ~IEnvironment() = default;
    
    // Required: Get variable value
    virtual Value Get(const std::string& name) = 0;
    
    // Required: Call function
    virtual Value Call(const std::string& name, 
                      const std::vector<Value>& args) = 0;
};
```

Advantages of this design:
- **Decoupling**: Separates expression parsing from concrete data sources
- **Flexibility**: Can integrate with any data source (database, config files, game state, etc.)
- **Testability**: Easy to create mock IEnvironments for different scenarios
- **Performance**: Avoids string lookups, supports direct memory access

## üìä Performance Characteristics

### Benefits of Pre-Parsed AST

1. **Parse once, execute many times**
   ```cpp
   // Slow: parse every time
   for (int i = 0; i < 1000000; ++i) {
       auto result = Expression::Eval("complex_expression", &environment);
   }
   
   // Fast: pre-parse and reuse
   auto ast = Expression::Parse("complex_expression");
   for (int i = 0; i < 1000000; ++i) {
       auto result = ast->evaluate(&environment);
   }
   ```

2. **Memory efficiency**: AST nodes use shared_ptr for safety and efficiency
3. **Type safety**: Compile-time type checking and runtime validation

## üéØ Use Cases

- **Game engines**: Skill systems, AI condition checks, configuration expressions
- **Configuration systems**: Dynamic rules, conditional logic
- **Business rule engines**: Complex business logic expressions
- **Data processing**: Computed fields, filtering conditions
- **Scripting systems**: Embedded expression evaluation

## üîç Error Handling

ExpressionKit uses exceptions for error handling:

```cpp
try {
    auto result = Expression::Eval("invalid expression ++ --", &environment);
} catch (const ExpressionKit::ExprException& e) {
    std::cerr << "Expression error: " << e.what() << std::endl;
}
```

Common error types:
- Syntax errors: Invalid expression syntax
- Type errors: Mismatched operand types
- Runtime errors: Division by zero, undefined variables, etc.
- Function errors: Unknown functions, incorrect arguments

## üöß Compilation Requirements

- C++11 or later
- Only depends on the C++ standard library

## üìö More Examples

### Running Token Demo

See comprehensive token functionality demonstrations:

#### C++ Token Demo
```bash
# Compile and run the C++ token demo
cd CPP
g++ -std=c++17 -I.. -o token_demo token_demo.cpp
./token_demo

# Or with CMake
mkdir build && cd build
cmake .. && make
./TokenDemo
```

#### Swift Token Demo
```bash
# Run the Swift example with token features
cd Swift/Examples/SwiftExample
swift run
```

See the `CPP/token_demo.cpp` and `Swift/Examples/SwiftExample/Sources/ExpressionKitExample/main.swift` files for complete working examples of token collection and analysis.

### Additional Examples

See the `test.cpp` file for additional usage examples and test cases.

## ü§ù Contributing

As this project is primarily AI-generated, for suggested changes:
1. Provide specific feature requirements
2. Describe the desired API design
3. Include test cases

## üìû Support

For questions or suggestions, please open an Issue or review the code comments for implementation details.
