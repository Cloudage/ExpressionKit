# ExpressionKit

A lightweight, interface-driven C++ expression parsing and evaluation library with Swift support

## ğŸš€ Key Features

- **Interface-based variable read/write**: Flexible access to variables and functions via the IBackend interface  
- **Pre-parsed AST execution**: Supports expression pre-compilation for efficient repeated execution
- **Type safety**: Strongly-typed Value system supporting numeric and boolean types
- **Complete operator support**: Full coverage of arithmetic, comparison, and logical operators
- **Exception-based error handling**: Clear error messages and robust exception mechanism
- **Zero dependencies**: Depends only on the C++ standard library
- **Swift Support**: Clean Swift API with Swift Package Manager integration

## ğŸ§ª Test Status

[![Test Status Check](https://github.com/Cloudage/ExpressionKit/actions/workflows/test-status-check.yml/badge.svg)](https://github.com/Cloudage/ExpressionKit/actions/workflows/test-status-check.yml)

### Automated Testing

This repository uses automated testing with GitHub Actions to ensure code quality and reliability:

- **C++ Core Library**: Comprehensive testing using Catch2 framework
- **Swift Wrapper**: Testing via XCTest framework with Swift Package Manager

**View Latest Test Results**: Click the badge above or visit the [Actions tab](https://github.com/Cloudage/ExpressionKit/actions/workflows/test-status-check.yml) to see detailed test results, including test counts, assertions, and execution summaries.

### Running Tests Locally

```bash
# Run all tests
./scripts/run_all_tests.sh

# Run individual test suites
./scripts/run_cpp_tests.sh      # C++ tests only
./scripts/run_swift_tests.sh    # Swift tests only
```
## ğŸ¤– AI-Generated Code Notice

**Important: The code in this project is primarily generated by AI tools (e.g., GitHub Copilot), under human guidance and review.**

The code follows modern C++ best practices and provides a clean, interface-based expression evaluation system.

## ğŸ› ï¸ Setup & Installation

### For Swift Projects (Recommended)

ExpressionKit can be easily integrated into Swift projects using **Swift Package Manager**:

#### Option 1: Xcode Integration
1. Open your Xcode project
2. Go to **File** â†’ **Add Package Dependencies**
3. Enter repository URL: `https://github.com/Cloudage/ExpressionKit.git`
4. Select version (from `1.0.0`)

#### Option 2: Package.swift
Add to your `Package.swift` dependencies:

```swift
dependencies: [
    .package(url: "https://github.com/Cloudage/ExpressionKit.git", from: "1.0.0")
]
```

Then import and use:

```swift
import ExpressionKit

// Direct evaluation
let result = try ExpressionKit.evaluate("2 + 3 * 4")  // 14.0

// Parse once, execute many times (high performance)
let expression = try ExpressionKit.parse("(a + b) * c - 1")
for _ in 0..<10000 {
    let result = try expression.evaluate()  // Very fast!
}
```

**ğŸ“– For complete Swift documentation, see [SWIFT_USAGE.md](SWIFT_USAGE.md)**

### For C++ Projects

For C++ projects, simply **copy the single header file** `ExpressionKit.hpp` to your project:

1. **Download**: Copy `ExpressionKit.hpp` from this repository
2. **Include**: Add `#include "ExpressionKit.hpp"` to your C++ files
3. **Compile**: Requires C++11 or later, no external dependencies

```cpp
#include "ExpressionKit.hpp"
using namespace ExpressionKit;

// Evaluate simple math expressions
auto result = ExprTK::Eval("2 + 3 * 4");  // Returns 14.0
std::cout << "Result: " << result.asNumber() << std::endl;

// Boolean expressions
auto boolResult = ExprTK::Eval("true && false");  // Returns false
std::cout << "Boolean result: " << boolResult.asBoolean() << std::endl;
```

## ğŸ“Š Quick Comparison

| Feature | Swift | C++ |
|---------|-------|-----|
| **Setup** | Swift Package Manager | Copy single .hpp file |
| **Dependencies** | None (handled by SPM) | None (header-only) |
| **Integration** | `import ExpressionKit` | `#include "ExpressionKit.hpp"` |
| **API** | `ExpressionKit.evaluate()` | `ExprTK::Eval()` |
| **Performance** | âœ… Full performance | âœ… Full performance |
| **Features** | âœ… All core features | âœ… All features + Backend |

### Which Version Should I Use?

- **ğŸ¯ Swift Projects**: Use Swift Package Manager integration for clean, type-safe API
- **ğŸ”§ C++ Projects**: Copy `ExpressionKit.hpp` for zero-dependency, header-only solution  
- **ğŸ—ï¸ Mixed Projects**: Both can coexist - same expression syntax and behavior

## ğŸš€ Examples

## ğŸš€ Examples

### Swift Examples

```swift
import ExpressionKit

// Basic arithmetic
let result1 = try ExpressionKit.evaluate("2 + 3 * 4")  // 14.0

// Boolean logic
let result2 = try ExpressionKit.evaluate("true && (5 > 3)")  // true

// Complex expressions
let result3 = try ExpressionKit.evaluate("(2 + 3) * 4 - 1")  // 19.0

// Parse once, execute many times for high performance
let expression = try ExpressionKit.parse("(a + b) * c - 1")
for _ in 0..<10000 {
    let result = try expression.evaluate()  // Very fast repeated execution
}

// Error handling
do {
    let result = try ExpressionKit.evaluate("1 / 0")
} catch let error as ExpressionError {
    print("Expression error: \(error.localizedDescription)")
}
```

### Using IBackend for Variable Access (C++)

```cpp
#include "ExpressionKit.hpp"
#include <unordered_map>

class GameBackend : public ExpressionKit::IBackend {
private:
    std::unordered_map<std::string, ExpressionKit::Value> variables;
    
public:
    GameBackend() {
        // Initialize game state
        variables["health"] = 100.0;
        variables["maxHealth"] = 100.0;
        variables["level"] = 5.0;
        variables["isAlive"] = true;
        variables["pos.x"] = 10.5;
        variables["pos.y"] = 20.3;
    }
    
    // Implement variable reading
    ExpressionKit::Value Get(const std::string& name) override {
        auto it = variables.find(name);
        if (it == variables.end()) {
            throw ExpressionKit::ExprException("Variable not found: " + name);
        }
        return it->second;
    }
    
    // Implement function calls
    ExpressionKit::Value Call(const std::string& name, 
                             const std::vector<ExpressionKit::Value>& args) override {
        // Try standard mathematical functions first
        ExpressionKit::Value result;
        if (ExpressionKit::ExprTK::CallStandardFunctions(name, args, result)) {
            return result;
        }
        
        // Custom functions
        if (name == "distance" && args.size() == 4) {
            double x1 = args[0].asNumber(), y1 = args[1].asNumber();
            double x2 = args[2].asNumber(), y2 = args[3].asNumber();
            double dx = x2 - x1, dy = y2 - y1;
            return ExpressionKit::Value(std::sqrt(dx*dx + dy*dy));
        }
        throw ExpressionKit::ExprException("Unknown function: " + name);
    }
};

// Usage example
int main() {
    GameBackend backend;
    
    // Game logic expressions
    auto healthPercent = ExprTK::Eval("health / maxHealth", &backend);
    std::cout << "Health percentage: " << healthPercent.asNumber() << std::endl;
    
    // Complex condition checks
    auto needHealing = ExprTK::Eval("health < maxHealth * 0.5 && isAlive", &backend);
    std::cout << "Needs healing: " << (needHealing.asBoolean() ? "Yes" : "No") << std::endl;
    
    // Function calls
    auto playerPos = ExprTK::Eval("distance(pos.x, pos.y, 0, 0)", &backend);
    std::cout << "Distance from origin: " << playerPos.asNumber() << std::endl;
    
    return 0;
}
```

### High-Performance Execution with Pre-Parsed AST (C++)

A key feature of ExpressionKit is support for **pre-parsed ASTs**, allowing you to:
1. Parse expressions once
2. Execute them efficiently multiple times
3. Avoid repeated parsing overhead

```cpp
#include "ExpressionKit.hpp"

class HighPerformanceExample {
private:
    GameBackend backend;
    // Pre-compiled expression ASTs
    std::shared_ptr<ExpressionKit::ASTNode> healthCheckExpr;
    std::shared_ptr<ExpressionKit::ASTNode> damageCalcExpr;
    std::shared_ptr<ExpressionKit::ASTNode> levelUpExpr;
    
public:
    HighPerformanceExample() {
        // Pre-compile all expressions at startup
        healthCheckExpr = ExprTK::Parse("health > 0 && health <= maxHealth");
        damageCalcExpr = ExprTK::Parse("max(0, damage - armor) * (1.0 + level * 0.1)");
        levelUpExpr = ExprTK::Parse("exp >= level * 100");
    }
    
    // Efficient execution in game loop
    void gameLoop() {
        for (int frame = 0; frame < 10000; ++frame) {
            // Execute every frame without re-parsing
            bool playerAlive = healthCheckExpr->evaluate(&backend).asBoolean();
            
            if (playerAlive) {
                // Calculate damage (assuming damage and armor are set)
                double finalDamage = damageCalcExpr->evaluate(&backend).asNumber();
                
                // Check level up
                bool canLevelUp = levelUpExpr->evaluate(&backend).asBoolean();
                
                // Game logic...
            }
        }
    }
};
```

## ğŸ“„ License

This project is licensed under the MIT License â€“ see the license notice in the file headers.

## ğŸ”§ Supported Syntax (Both C++ and Swift)

### Data Types
- **Numbers**: `42`, `3.14`, `-2.5`
- **Booleans**: `true`, `false`

### Operators (by precedence)

| Precedence | Operator | Description | Example |
|----------|---------|-------------|---------|
| 1 | `()` | Grouping | `(a + b) * c` |
| 2 | `!`, `not`, `-` | Unary operators | `!flag`, `not visible`, `-value` |
| 3 | `*`, `/` | Multiplication/Division | `a * b`, `x / y` |
| 4 | `+`, `-` | Addition/Subtraction | `a + b`, `x - y` |
| 5 | `<`, `>`, `<=`, `>=` | Relational comparison | `age >= 18`, `score < 100` |
| 6 | `==`, `!=` | Equality comparison | `name == "admin"`, `id != 0` |
| 7 | `xor` | Logical XOR | `a xor b` |
| 8 | `&&`, `and` | Logical AND | `a && b`, `x and y` |
| 9 | `\|\|`, `or` | Logical OR | `a \|\| b`, `x or y` |

### Variables and Functions
- **Variables**: `x`, `health`, `pos.x`, `player_name`
- **Function calls**: `max(a, b)`, `sqrt(x)`, `distance(x1, y1, x2, y2)`

### Built-in Mathematical Functions
ExpressionKit provides a comprehensive set of standard mathematical functions through the `CallStandardFunctions` method:

| Function | Description | Example |
|----------|-------------|---------|
| `min(a, b)` | Returns the smaller of two numbers | `min(10, 5)` â†’ `5` |
| `max(a, b)` | Returns the larger of two numbers | `max(10, 5)` â†’ `10` |
| `sqrt(x)` | Returns the square root of x | `sqrt(16)` â†’ `4` |
| `sin(x)` | Returns the sine of x (radians) | `sin(3.14159/2)` â†’ `1` |
| `cos(x)` | Returns the cosine of x (radians) | `cos(0)` â†’ `1` |
| `tan(x)` | Returns the tangent of x (radians) | `tan(0)` â†’ `0` |
| `abs(x)` | Returns the absolute value of x | `abs(-5)` â†’ `5` |
| `pow(x, y)` | Returns x raised to the power of y | `pow(2, 3)` â†’ `8` |
| `log(x)` | Returns the natural logarithm of x | `log(2.718)` â†’ `â‰ˆ1` |
| `exp(x)` | Returns e raised to the power of x | `exp(1)` â†’ `â‰ˆ2.718` |
| `floor(x)` | Returns the largest integer â‰¤ x | `floor(3.7)` â†’ `3` |
| `ceil(x)` | Returns the smallest integer â‰¥ x | `ceil(3.2)` â†’ `4` |
| `round(x)` | Returns x rounded to nearest integer | `round(3.6)` â†’ `4` |

These functions can be used in IBackend implementations to provide mathematical capabilities:

```cpp
class MathBackend : public ExpressionKit::IBackend {
public:
    ExpressionKit::Value Call(const std::string& name, 
                             const std::vector<ExpressionKit::Value>& args) override {
        ExpressionKit::Value result;
        
        // Try standard mathematical functions first
        if (ExpressionKit::ExprTK::CallStandardFunctions(name, args, result)) {
            return result;
        }
        
        // Custom functions...
        throw ExpressionKit::ExprException("Unknown function: " + name);
    }
    
    // ... other methods
};
```
## ğŸ—ï¸ Architecture Design

### Core Components

1. **Value** - Unified value type supporting numbers and booleans
2. **IBackend** - Interface for variable and function access
3. **ASTNode** - Base class for abstract syntax tree nodes
4. **Parser** - Recursive descent parser
5. **ExprTK** - Main expression utility class
6. **ExpressionKitBridge** - C bridge for Swift integration (located in `Sources/ExpressionKitBridge/`)

### Swift Integration Architecture

ExpressionKit provides seamless Swift integration through a layered architecture:

1. **ExpressionKit.hpp** - Core C++ header-only library
2. **ExpressionKitBridge** - C interface bridge that wraps the C++ code for Swift compatibility
3. **ExpressionKit (Swift)** - Swift wrapper providing idiomatic Swift APIs

```
Swift Code
    â†“
ExpressionKit (Swift Package)
    â†“
ExpressionKitBridge (C Interface)
    â†“
ExpressionKit.hpp (C++ Core)
```

This design ensures:
- **Clean separation**: Each layer has a clear responsibility
- **Swift safety**: The bridge handles C++/Swift interop complexities
- **Performance**: Minimal overhead between layers
- **Maintainability**: Changes to C++ core don't affect Swift API

### IBackend Interface

The IBackend is a core design pattern in ExpressionKit, providing:

```cpp
class IBackend {
public:
    virtual ~IBackend() = default;
    
    // Required: Get variable value
    virtual Value Get(const std::string& name) = 0;
    
    // Required: Call function
    virtual Value Call(const std::string& name, 
                      const std::vector<Value>& args) = 0;
};
```

Advantages of this design:
- **Decoupling**: Separates expression parsing from concrete data sources
- **Flexibility**: Can integrate with any data source (database, config files, game state, etc.)
- **Testability**: Easy to create mock IBackends for different scenarios
- **Performance**: Avoids string lookups, supports direct memory access

## ğŸ“Š Performance Characteristics

### Benefits of Pre-Parsed AST

1. **Parse once, execute many times**
   ```cpp
   // Slow: parse every time
   for (int i = 0; i < 1000000; ++i) {
       auto result = ExprTK::Eval("complex_expression", &backend);
   }
   
   // Fast: pre-parse and reuse
   auto ast = ExprTK::Parse("complex_expression");
   for (int i = 0; i < 1000000; ++i) {
       auto result = ast->evaluate(&backend);
   }
   ```

2. **Memory efficiency**: AST nodes use shared_ptr for safety and efficiency
3. **Type safety**: Compile-time type checking and runtime validation

## ğŸ¯ Use Cases

- **Game engines**: Skill systems, AI condition checks, configuration expressions
- **Configuration systems**: Dynamic rules, conditional logic
- **Business rule engines**: Complex business logic expressions
- **Data processing**: Computed fields, filtering conditions
- **Scripting systems**: Embedded expression evaluation

## ğŸ” Error Handling

ExpressionKit uses exceptions for error handling:

```cpp
try {
    auto result = ExprTK::Eval("invalid expression ++ --", &backend);
} catch (const ExpressionKit::ExprException& e) {
    std::cerr << "Expression error: " << e.what() << std::endl;
}
```

Common error types:
- Syntax errors: Invalid expression syntax
- Type errors: Mismatched operand types
- Runtime errors: Division by zero, undefined variables, etc.
- Function errors: Unknown functions, incorrect arguments

## ğŸš§ Compilation Requirements

- C++11 or later
- Only depends on the C++ standard library

## ğŸ“š More Examples

See the `test.cpp` file for additional usage examples and test cases.

## ğŸ¤ Contributing

As this project is primarily AI-generated, for suggested changes:
1. Provide specific feature requirements
2. Describe the desired API design
3. Include test cases

## ğŸ“ Support

For questions or suggestions, please open an Issue or review the code comments for implementation details.

---

# ExpressionKit

ä¸€ä¸ªè½»é‡çº§ã€æ¥å£é©±åŠ¨çš„C++è¡¨è¾¾å¼è§£æä¸æ±‚å€¼åº“

## ğŸš€ ä¸»è¦ç‰¹æ€§

- **æ¥å£åŒ–å˜é‡è¯»å†™**ï¼šé€šè¿‡IBackendæ¥å£å®ç°å˜é‡å’Œå‡½æ•°çš„çµæ´»è®¿é—®
- **é¢„è§£æASTæ‰§è¡Œ**ï¼šæ”¯æŒè¡¨è¾¾å¼é¢„ç¼–è¯‘ï¼Œå¯é‡å¤é«˜æ•ˆæ‰§è¡Œ
- **ç±»å‹å®‰å…¨**ï¼šå¼ºç±»å‹Valueç³»ç»Ÿï¼Œæ”¯æŒæ•°å€¼å’Œå¸ƒå°”ç±»å‹
- **å®Œæ•´è¿ç®—ç¬¦æ”¯æŒ**ï¼šç®—æœ¯ã€æ¯”è¾ƒã€é€»è¾‘è¿ç®—ç¬¦å…¨è¦†ç›–
- **å¼‚å¸¸é”™è¯¯å¤„ç†**ï¼šæ¸…æ™°çš„é”™è¯¯ä¿¡æ¯å’Œå¼‚å¸¸æœºåˆ¶
- **é›¶ä¾èµ–**ï¼šä»…ä¾èµ–C++æ ‡å‡†åº“

## ğŸ¤– AIç”Ÿæˆå£°æ˜

**é‡è¦æç¤ºï¼šæœ¬é¡¹ç›®ä»£ç ä¸»è¦ç”±AIï¼ˆGitHub Copilotç­‰AIå·¥å…·ï¼‰ç”Ÿæˆï¼Œç»è¿‡äººå·¥æŒ‡å¯¼å’Œå®¡æŸ¥ã€‚**

ä»£ç éµå¾ªç°ä»£C++æœ€ä½³å®è·µï¼Œæä¾›äº†ä¸€ä¸ªæ¸…æ´ã€åŸºäºæ¥å£çš„è¡¨è¾¾å¼æ±‚å€¼ç³»ç»Ÿã€‚

## ğŸ“„ è®¸å¯è¯

æœ¬é¡¹ç›®é‡‡ç”¨MITè®¸å¯è¯ - è¯¦è§æ–‡ä»¶å¤´éƒ¨çš„è®¸å¯è¯å£°æ˜ã€‚

## ğŸ› ï¸ å¿«é€Ÿå¼€å§‹

### åŸºæœ¬ç”¨æ³•

```cpp
#include "ExpressionKit.hpp"
using namespace ExpressionKit;

// ç®€å•çš„æ•°å­¦è¡¨è¾¾å¼æ±‚å€¼
auto result = ExprTK::Eval("2 + 3 * 4");  // è¿”å› 14.0
std::cout << "ç»“æœ: " << result.asNumber() << std::endl;

// å¸ƒå°”è¡¨è¾¾å¼
auto boolResult = ExprTK::Eval("true && false");  // è¿”å› false
std::cout << "å¸ƒå°”ç»“æœ: " << boolResult.asBoolean() << std::endl;
```

### ä½¿ç”¨IBackendå®ç°å˜é‡è®¿é—®

```cpp
#include "ExpressionKit.hpp"
#include <unordered_map>

class GameBackend : public ExpressionKit::IBackend {
private:
    std::unordered_map<std::string, ExpressionKit::Value> variables;
    
public:
    GameBackend() {
        // åˆå§‹åŒ–æ¸¸æˆçŠ¶æ€
        variables["health"] = 100.0;
        variables["maxHealth"] = 100.0;
        variables["level"] = 5.0;
        variables["isAlive"] = true;
        variables["pos.x"] = 10.5;
        variables["pos.y"] = 20.3;
    }
    
    // å®ç°å˜é‡è¯»å–
    ExpressionKit::Value Get(const std::string& name) override {
        auto it = variables.find(name);
        if (it == variables.end()) {
            throw ExpressionKit::ExprException("æœªæ‰¾åˆ°å˜é‡: " + name);
        }
        return it->second;
    }
    
    // å®ç°å‡½æ•°è°ƒç”¨
    ExpressionKit::Value Call(const std::string& name, 
                             const std::vector<ExpressionKit::Value>& args) override {
        // å…ˆå°è¯•æ ‡å‡†æ•°å­¦å‡½æ•°
        ExpressionKit::Value result;
        if (ExpressionKit::ExprTK::CallStandardFunctions(name, args, result)) {
            return result;
        }
        
        // è‡ªå®šä¹‰å‡½æ•°
        if (name == "distance" && args.size() == 4) {
            double x1 = args[0].asNumber(), y1 = args[1].asNumber();
            double x2 = args[2].asNumber(), y2 = args[3].asNumber();
            double dx = x2 - x1, dy = y2 - y1;
            return ExpressionKit::Value(std::sqrt(dx*dx + dy*dy));
        }
        throw ExpressionKit::ExprException("æœªçŸ¥å‡½æ•°: " + name);
    }
};

// ä½¿ç”¨ç¤ºä¾‹
int main() {
    GameBackend backend;
    
    // æ¸¸æˆé€»è¾‘è¡¨è¾¾å¼
    auto healthPercent = ExprTK::Eval("health / maxHealth", &backend);
    std::cout << "ç”Ÿå‘½å€¼ç™¾åˆ†æ¯”: " << healthPercent.asNumber() << std::endl;
    
    // å¤æ‚æ¡ä»¶åˆ¤æ–­
    auto needHealing = ExprTK::Eval("health < maxHealth * 0.5 && isAlive", &backend);
    std::cout << "éœ€è¦æ²»ç–—: " << (needHealing.asBoolean() ? "æ˜¯" : "å¦") << std::endl;
    
    // å‡½æ•°è°ƒç”¨
    auto playerPos = ExprTK::Eval("distance(pos.x, pos.y, 0, 0)", &backend);
    std::cout << "è·ç¦»åŸç‚¹: " << playerPos.asNumber() << std::endl;
    
    return 0;
}
```

### é¢„è§£æASTé«˜æ€§èƒ½æ‰§è¡Œ

ExpressionKitçš„ä¸€ä¸ªå…³é”®ç‰¹æ€§æ˜¯æ”¯æŒ**é¢„è§£æAST**ï¼Œè¿™å…è®¸ä½ ï¼š
1. ä¸€æ¬¡è§£æè¡¨è¾¾å¼
2. å¤šæ¬¡é«˜æ•ˆæ‰§è¡Œ
3. é¿å…é‡å¤è§£æå¼€é”€

```cpp
#include "ExpressionKit.hpp"

class HighPerformanceExample {
private:
    GameBackend backend;
    // é¢„ç¼–è¯‘çš„è¡¨è¾¾å¼AST
    std::shared_ptr<ExpressionKit::ASTNode> healthCheckExpr;
    std::shared_ptr<ExpressionKit::ASTNode> damageCalcExpr;
    std::shared_ptr<ExpressionKit::ASTNode> levelUpExpr;
    
public:
    HighPerformanceExample() {
        // æ¸¸æˆå¯åŠ¨æ—¶é¢„ç¼–è¯‘æ‰€æœ‰è¡¨è¾¾å¼
        healthCheckExpr = ExprTK::Parse("health > 0 && health <= maxHealth");
        damageCalcExpr = ExprTK::Parse("max(0, damage - armor) * (1.0 + level * 0.1)");
        levelUpExpr = ExprTK::Parse("exp >= level * 100");
    }
    
    // æ¸¸æˆå¾ªç¯ä¸­é«˜æ•ˆæ‰§è¡Œ
    void gameLoop() {
        for (int frame = 0; frame < 10000; ++frame) {
            // æ¯å¸§éƒ½æ‰§è¡Œï¼Œä½†ä¸éœ€è¦é‡æ–°è§£æ
            bool playerAlive = healthCheckExpr->evaluate(&backend).asBoolean();
            
            if (playerAlive) {
                // è®¡ç®—ä¼¤å®³ï¼ˆå‡è®¾è®¾ç½®äº†damageå’Œarmorå˜é‡ï¼‰
                double finalDamage = damageCalcExpr->evaluate(&backend).asNumber();
                
                // æ£€æŸ¥å‡çº§
                bool canLevelUp = levelUpExpr->evaluate(&backend).asBoolean();
                
                // æ¸¸æˆé€»è¾‘...
            }
        }
    }
};
```

## ğŸ”§ æ”¯æŒçš„è¯­æ³•

### æ•°æ®ç±»å‹
- **æ•°å€¼**: `42`, `3.14`, `-2.5`
- **å¸ƒå°”å€¼**: `true`, `false`

### è¿ç®—ç¬¦ï¼ˆæŒ‰ä¼˜å…ˆçº§æ’åºï¼‰

| ä¼˜å…ˆçº§ | è¿ç®—ç¬¦ | è¯´æ˜ | ç¤ºä¾‹ |
|--------|--------|------|------|
| 1 | `()` | æ‹¬å·åˆ†ç»„ | `(a + b) * c` |
| 2 | `!`, `not`, `-` | ä¸€å…ƒè¿ç®—ç¬¦ | `!flag`, `not visible`, `-value` |
| 3 | `*`, `/` | ä¹˜é™¤è¿ç®— | `a * b`, `x / y` |
| 4 | `+`, `-` | åŠ å‡è¿ç®— | `a + b`, `x - y` |
| 5 | `<`, `>`, `<=`, `>=` | å…³ç³»æ¯”è¾ƒ | `age >= 18`, `score < 100` |
| 6 | `==`, `!=` | ç›¸ç­‰æ¯”è¾ƒ | `name == "admin"`, `id != 0` |
| 7 | `xor` | é€»è¾‘å¼‚æˆ– | `a xor b` |
| 8 | `&&`, `and` | é€»è¾‘ä¸ | `a && b`, `x and y` |
| 9 | `\|\|`, `or` | é€»è¾‘æˆ– | `a \|\| b`, `x or y` |

### å˜é‡å’Œå‡½æ•°
- **å˜é‡**: `x`, `health`, `pos.x`, `player_name`
- **å‡½æ•°è°ƒç”¨**: `max(a, b)`, `sqrt(x)`, `distance(x1, y1, x2, y2)`

### å†…ç½®æ•°å­¦å‡½æ•°
ExpressionKité€šè¿‡`CallStandardFunctions`æ–¹æ³•æä¾›äº†ä¸€å¥—å®Œæ•´çš„æ ‡å‡†æ•°å­¦å‡½æ•°ï¼š

| å‡½æ•° | è¯´æ˜ | ç¤ºä¾‹ |
|------|------|------|
| `min(a, b)` | è¿”å›ä¸¤ä¸ªæ•°ä¸­çš„è¾ƒå°å€¼ | `min(10, 5)` â†’ `5` |
| `max(a, b)` | è¿”å›ä¸¤ä¸ªæ•°ä¸­çš„è¾ƒå¤§å€¼ | `max(10, 5)` â†’ `10` |
| `sqrt(x)` | è¿”å›xçš„å¹³æ–¹æ ¹ | `sqrt(16)` â†’ `4` |
| `sin(x)` | è¿”å›xçš„æ­£å¼¦å€¼ï¼ˆå¼§åº¦ï¼‰ | `sin(3.14159/2)` â†’ `1` |
| `cos(x)` | è¿”å›xçš„ä½™å¼¦å€¼ï¼ˆå¼§åº¦ï¼‰ | `cos(0)` â†’ `1` |
| `tan(x)` | è¿”å›xçš„æ­£åˆ‡å€¼ï¼ˆå¼§åº¦ï¼‰ | `tan(0)` â†’ `0` |
| `abs(x)` | è¿”å›xçš„ç»å¯¹å€¼ | `abs(-5)` â†’ `5` |
| `pow(x, y)` | è¿”å›xçš„yæ¬¡å¹‚ | `pow(2, 3)` â†’ `8` |
| `log(x)` | è¿”å›xçš„è‡ªç„¶å¯¹æ•° | `log(2.718)` â†’ `â‰ˆ1` |
| `exp(x)` | è¿”å›eçš„xæ¬¡å¹‚ | `exp(1)` â†’ `â‰ˆ2.718` |
| `floor(x)` | è¿”å›ä¸å¤§äºxçš„æœ€å¤§æ•´æ•° | `floor(3.7)` â†’ `3` |
| `ceil(x)` | è¿”å›ä¸å°äºxçš„æœ€å°æ•´æ•° | `ceil(3.2)` â†’ `4` |
| `round(x)` | è¿”å›å››èˆäº”å…¥åçš„æ•´æ•° | `round(3.6)` â†’ `4` |

è¿™äº›å‡½æ•°å¯ä»¥åœ¨IBackendå®ç°ä¸­ä½¿ç”¨ï¼Œä»¥æä¾›æ•°å­¦è®¡ç®—èƒ½åŠ›ï¼š

```cpp
class MathBackend : public ExpressionKit::IBackend {
public:
    ExpressionKit::Value Call(const std::string& name, 
                             const std::vector<ExpressionKit::Value>& args) override {
        ExpressionKit::Value result;
        
        // å…ˆå°è¯•æ ‡å‡†æ•°å­¦å‡½æ•°
        if (ExpressionKit::ExprTK::CallStandardFunctions(name, args, result)) {
            return result;
        }
        
        // è‡ªå®šä¹‰å‡½æ•°...
        throw ExpressionKit::ExprException("æœªçŸ¥å‡½æ•°: " + name);
    }
    
    // ... å…¶ä»–æ–¹æ³•
};
```
## ğŸ—ï¸ æ¶æ„è®¾è®¡

### æ ¸å¿ƒç»„ä»¶

1. **Value** - ç»Ÿä¸€çš„å€¼ç±»å‹ï¼Œæ”¯æŒæ•°å€¼å’Œå¸ƒå°”
2. **IBackend** - å˜é‡å’Œå‡½æ•°è®¿é—®æ¥å£
3. **ASTNode** - æŠ½è±¡è¯­æ³•æ ‘èŠ‚ç‚¹åŸºç±»
4. **Parser** - é€’å½’ä¸‹é™è§£æå™¨
5. **ExprTK** - ä¸»è¦çš„è¡¨è¾¾å¼å·¥å…·ç±»

### IBackendæ¥å£

IBackendæ˜¯ExpressionKitçš„æ ¸å¿ƒè®¾è®¡æ¨¡å¼ï¼Œå®ƒæä¾›äº†ï¼š

```cpp
class IBackend {
public:
    virtual ~IBackend() = default;
    
    // å¿…é¡»å®ç°ï¼šè·å–å˜é‡å€¼
    virtual Value Get(const std::string& name) = 0;
    
    // å¿…é¡»å®ç°ï¼šè°ƒç”¨å‡½æ•°
    virtual Value Call(const std::string& name, 
                      const std::vector<Value>& args) = 0;
};
```

è¿™ç§è®¾è®¡çš„ä¼˜åŠ¿ï¼š
- **è§£è€¦**ï¼šè¡¨è¾¾å¼è§£æä¸å…·ä½“æ•°æ®æºåˆ†ç¦»
- **çµæ´»**ï¼šå¯ä»¥æ¥å…¥ä»»ä½•æ•°æ®æºï¼ˆæ•°æ®åº“ã€é…ç½®æ–‡ä»¶ã€æ¸¸æˆçŠ¶æ€ç­‰ï¼‰
- **å¯æµ‹è¯•**ï¼šæ˜“äºä¸ºä¸åŒåœºæ™¯åˆ›å»ºMock IBackend
- **é«˜æ€§èƒ½**ï¼šé¿å…å­—ç¬¦ä¸²æŸ¥æ‰¾ï¼Œæ”¯æŒç›´æ¥å†…å­˜è®¿é—®

## ğŸ“Š æ€§èƒ½ç‰¹æ€§

### é¢„è§£æASTçš„ä¼˜åŠ¿

1. **ä¸€æ¬¡è§£æï¼Œå¤šæ¬¡æ‰§è¡Œ**
   ```cpp
   // æ…¢ï¼šæ¯æ¬¡éƒ½è§£æ
   for (int i = 0; i < 1000000; ++i) {
       auto result = ExprTK::Eval("complex_expression", &backend);
   }
   
   // å¿«ï¼šé¢„è§£æåé‡å¤æ‰§è¡Œ
   auto ast = ExprTK::Parse("complex_expression");
   for (int i = 0; i < 1000000; ++i) {
       auto result = ast->evaluate(&backend);
   }
   ```

2. **å†…å­˜æ•ˆç‡**: ASTèŠ‚ç‚¹ä½¿ç”¨shared_ptrï¼Œå®‰å…¨ä¸”é«˜æ•ˆ
3. **ç±»å‹å®‰å…¨**: ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥ï¼Œè¿è¡Œæ—¶ç±»å‹éªŒè¯

## ğŸ¯ ä½¿ç”¨åœºæ™¯

- **æ¸¸æˆå¼•æ“**: æŠ€èƒ½ç³»ç»Ÿã€AIæ¡ä»¶åˆ¤æ–­ã€é…ç½®è¡¨è¾¾å¼
- **é…ç½®ç³»ç»Ÿ**: åŠ¨æ€é…ç½®è§„åˆ™ã€æ¡ä»¶åˆ¤æ–­
- **ä¸šåŠ¡è§„åˆ™å¼•æ“**: å¤æ‚ä¸šåŠ¡é€»è¾‘è¡¨è¾¾å¼
- **æ•°æ®å¤„ç†**: è®¡ç®—å­—æ®µã€è¿‡æ»¤æ¡ä»¶
- **è„šæœ¬ç³»ç»Ÿ**: åµŒå…¥å¼è¡¨è¾¾å¼æ±‚å€¼

## ğŸ” é”™è¯¯å¤„ç†

ExpressionKitä½¿ç”¨å¼‚å¸¸æœºåˆ¶å¤„ç†é”™è¯¯ï¼š

```cpp
try {
    auto result = ExprTK::Eval("invalid expression ++ --", &backend);
} catch (const ExpressionKit::ExprException& e) {
    std::cerr << "è¡¨è¾¾å¼é”™è¯¯: " << e.what() << std::endl;
}
```

å¸¸è§é”™è¯¯ç±»å‹ï¼š
- è¯­æ³•é”™è¯¯ï¼šæ— æ•ˆçš„è¡¨è¾¾å¼è¯­æ³•
- ç±»å‹é”™è¯¯ï¼šç±»å‹ä¸åŒ¹é…çš„æ“ä½œ
- è¿è¡Œæ—¶é”™è¯¯ï¼šé™¤é›¶ã€æœªå®šä¹‰å˜é‡ç­‰
- å‡½æ•°é”™è¯¯ï¼šæœªçŸ¥å‡½æ•°ã€å‚æ•°ä¸åŒ¹é…

## ğŸš§ ç¼–è¯‘è¦æ±‚

- C++11 æˆ–æ›´é«˜ç‰ˆæœ¬
- ä»…ä¾èµ–C++æ ‡å‡†åº“

## ğŸ“š æ›´å¤šç¤ºä¾‹

æŸ¥çœ‹ `test.cpp` æ–‡ä»¶ä»¥è·å–æ›´å¤šä½¿ç”¨ç¤ºä¾‹å’Œæµ‹è¯•ç”¨ä¾‹ã€‚

## ğŸ¤ è´¡çŒ®

ç”±äºæœ¬é¡¹ç›®ä¸»è¦ç”±AIç”Ÿæˆï¼Œå¦‚éœ€ä¿®æ”¹å»ºè®®ï¼š
1. æå‡ºå…·ä½“çš„åŠŸèƒ½éœ€æ±‚
2. æè¿°é¢„æœŸçš„APIè®¾è®¡
3. æä¾›æµ‹è¯•ç”¨ä¾‹

## ğŸ“ æ”¯æŒ

å¦‚æœ‰é—®é¢˜æˆ–å»ºè®®ï¼Œè¯·åˆ›å»ºIssueæˆ–æŸ¥çœ‹ä»£ç æ³¨é‡Šä»¥äº†è§£å®ç°ç»†èŠ‚ã€‚
