# ExpressionKit

A lightweight, interface-driven C++ expression parsing and evaluation library with Swift support

## üöÄ Key Features

- **Interface-based variable read/write**: Flexible access to variables and functions via the IBackend interface  
- **Pre-parsed AST execution**: Supports expression pre-compilation for efficient repeated execution
- **Type safety**: Strongly-typed Value system supporting numeric and boolean types
- **Complete operator support**: Full coverage of arithmetic, comparison, and logical operators
- **Exception-based error handling**: Clear error messages and robust exception mechanism
- **Zero dependencies**: Depends only on the C++ standard library
- **Swift Support**: Clean Swift API with Swift Package Manager integration

## üß™ Test Status

[![Test Status Check](https://github.com/Cloudage/ExpressionKit/actions/workflows/test-status-check.yml/badge.svg)](https://github.com/Cloudage/ExpressionKit/actions/workflows/test-status-check.yml)

### Automated Testing

This repository uses automated testing with GitHub Actions to ensure code quality and reliability:

- **C++ Core Library**: Comprehensive testing using Catch2 framework
- **Swift Wrapper**: Testing via XCTest framework with Swift Package Manager

**View Latest Test Results**: Click the badge above or visit the [Actions tab](https://github.com/Cloudage/ExpressionKit/actions/workflows/test-status-check.yml) to see detailed test results, including test counts, assertions, and execution summaries.

### Running Tests Locally

```bash
# Run all tests
./scripts/run_all_tests.sh

# Run individual test suites
./scripts/run_cpp_tests.sh      # C++ tests only
./scripts/run_swift_tests.sh    # Swift tests only
```
## ü§ñ AI-Generated Code Notice

**Important: The code in this project is primarily generated by AI tools (e.g., GitHub Copilot), under human guidance and review.**

The code follows modern C++ best practices and provides a clean, interface-based expression evaluation system.

## üõ†Ô∏è Setup & Installation

### For Swift Projects (Recommended)

ExpressionKit can be easily integrated into Swift projects using **Swift Package Manager**:

#### Option 1: Xcode Integration
1. Open your Xcode project
2. Go to **File** ‚Üí **Add Package Dependencies**
3. Enter repository URL: `https://github.com/Cloudage/ExpressionKit.git`
4. Select version (from `1.0.0`)

#### Option 2: Package.swift
Add to your `Package.swift` dependencies:

```swift
dependencies: [
    .package(url: "https://github.com/Cloudage/ExpressionKit.git", from: "1.0.0")
]
```

Then import and use:

```swift
import ExpressionKit

// Direct evaluation
let result = try ExpressionKit.evaluate("2 + 3 * 4")  // 14.0

// Parse once, execute many times (high performance)
let expression = try ExpressionKit.parse("(a + b) * c - 1")
for _ in 0..<10000 {
    let result = try expression.evaluate()  // Very fast!
}
```

**üìñ For complete Swift documentation, see [SWIFT_USAGE.md](SWIFT_USAGE.md)**

### For C++ Projects

For C++ projects, simply **copy the single header file** `ExpressionKit.hpp` to your project:

1. **Download**: Copy `ExpressionKit.hpp` from this repository
2. **Include**: Add `#include "ExpressionKit.hpp"` to your C++ files
3. **Compile**: Requires C++11 or later, no external dependencies

```cpp
#include "ExpressionKit.hpp"
using namespace ExpressionKit;

// Evaluate simple math expressions
auto result = ExprTK::Eval("2 + 3 * 4");  // Returns 14.0
std::cout << "Result: " << result.asNumber() << std::endl;

// Boolean expressions
auto boolResult = ExprTK::Eval("true && false");  // Returns false
std::cout << "Boolean result: " << boolResult.asBoolean() << std::endl;
```

## üìä Quick Comparison

| Feature | Swift | C++ |
|---------|-------|-----|
| **Setup** | Swift Package Manager | Copy single .hpp file |
| **Dependencies** | None (handled by SPM) | None (header-only) |
| **Integration** | `import ExpressionKit` | `#include "ExpressionKit.hpp"` |
| **API** | `ExpressionKit.evaluate()` | `ExprTK::Eval()` |
| **Performance** | ‚úÖ Full performance | ‚úÖ Full performance |
| **Features** | ‚úÖ All core features | ‚úÖ All features + Backend |

### Which Version Should I Use?

- **üéØ Swift Projects**: Use Swift Package Manager integration for clean, type-safe API
- **üîß C++ Projects**: Copy `ExpressionKit.hpp` for zero-dependency, header-only solution  
- **üèóÔ∏è Mixed Projects**: Both can coexist - same expression syntax and behavior

## üöÄ Examples

## üöÄ Examples

### Swift Examples

```swift
import ExpressionKit

// Basic arithmetic
let result1 = try ExpressionKit.evaluate("2 + 3 * 4")  // 14.0

// Boolean logic
let result2 = try ExpressionKit.evaluate("true && (5 > 3)")  // true

// Complex expressions
let result3 = try ExpressionKit.evaluate("(2 + 3) * 4 - 1")  // 19.0

// Parse once, execute many times for high performance
let expression = try ExpressionKit.parse("(a + b) * c - 1")
for _ in 0..<10000 {
    let result = try expression.evaluate()  // Very fast repeated execution
}

// Error handling
do {
    let result = try ExpressionKit.evaluate("1 / 0")
} catch let error as ExpressionError {
    print("Expression error: \(error.localizedDescription)")
}
```

### Using IBackend for Variable Access (C++)

```cpp
#include "ExpressionKit.hpp"
#include <unordered_map>

class GameBackend : public ExpressionKit::IBackend {
private:
    std::unordered_map<std::string, ExpressionKit::Value> variables;
    
public:
    GameBackend() {
        // Initialize game state
        variables["health"] = 100.0;
        variables["maxHealth"] = 100.0;
        variables["level"] = 5.0;
        variables["isAlive"] = true;
        variables["pos.x"] = 10.5;
        variables["pos.y"] = 20.3;
    }
    
    // Implement variable reading
    ExpressionKit::Value Get(const std::string& name) override {
        auto it = variables.find(name);
        if (it == variables.end()) {
            throw ExpressionKit::ExprException("Variable not found: " + name);
        }
        return it->second;
    }
    
    // Implement function calls
    ExpressionKit::Value Call(const std::string& name, 
                             const std::vector<ExpressionKit::Value>& args) override {
        // Try standard mathematical functions first
        ExpressionKit::Value result;
        if (ExpressionKit::ExprTK::CallStandardFunctions(name, args, result)) {
            return result;
        }
        
        // Custom functions
        if (name == "distance" && args.size() == 4) {
            double x1 = args[0].asNumber(), y1 = args[1].asNumber();
            double x2 = args[2].asNumber(), y2 = args[3].asNumber();
            double dx = x2 - x1, dy = y2 - y1;
            return ExpressionKit::Value(std::sqrt(dx*dx + dy*dy));
        }
        throw ExpressionKit::ExprException("Unknown function: " + name);
    }
};

// Usage example
int main() {
    GameBackend backend;
    
    // Game logic expressions
    auto healthPercent = ExprTK::Eval("health / maxHealth", &backend);
    std::cout << "Health percentage: " << healthPercent.asNumber() << std::endl;
    
    // Complex condition checks
    auto needHealing = ExprTK::Eval("health < maxHealth * 0.5 && isAlive", &backend);
    std::cout << "Needs healing: " << (needHealing.asBoolean() ? "Yes" : "No") << std::endl;
    
    // Function calls
    auto playerPos = ExprTK::Eval("distance(pos.x, pos.y, 0, 0)", &backend);
    std::cout << "Distance from origin: " << playerPos.asNumber() << std::endl;
    
    return 0;
}
```

### High-Performance Execution with Pre-Parsed AST (C++)

A key feature of ExpressionKit is support for **pre-parsed ASTs**, allowing you to:
1. Parse expressions once
2. Execute them efficiently multiple times
3. Avoid repeated parsing overhead

```cpp
#include "ExpressionKit.hpp"

class HighPerformanceExample {
private:
    GameBackend backend;
    // Pre-compiled expression ASTs
    std::shared_ptr<ExpressionKit::ASTNode> healthCheckExpr;
    std::shared_ptr<ExpressionKit::ASTNode> damageCalcExpr;
    std::shared_ptr<ExpressionKit::ASTNode> levelUpExpr;
    
public:
    HighPerformanceExample() {
        // Pre-compile all expressions at startup
        healthCheckExpr = ExprTK::Parse("health > 0 && health <= maxHealth");
        damageCalcExpr = ExprTK::Parse("max(0, damage - armor) * (1.0 + level * 0.1)");
        levelUpExpr = ExprTK::Parse("exp >= level * 100");
    }
    
    // Efficient execution in game loop
    void gameLoop() {
        for (int frame = 0; frame < 10000; ++frame) {
            // Execute every frame without re-parsing
            bool playerAlive = healthCheckExpr->evaluate(&backend).asBoolean();
            
            if (playerAlive) {
                // Calculate damage (assuming damage and armor are set)
                double finalDamage = damageCalcExpr->evaluate(&backend).asNumber();
                
                // Check level up
                bool canLevelUp = levelUpExpr->evaluate(&backend).asBoolean();
                
                // Game logic...
            }
        }
    }
};
```

## üìÑ License

This project is licensed under the MIT License ‚Äì see the license notice in the file headers.

## üîß Supported Syntax (Both C++ and Swift)

### Data Types
- **Numbers**: `42`, `3.14`, `-2.5`
- **Booleans**: `true`, `false`

### Operators (by precedence)

| Precedence | Operator | Description | Example |
|----------|---------|-------------|---------|
| 1 | `()` | Grouping | `(a + b) * c` |
| 2 | `!`, `not`, `-` | Unary operators | `!flag`, `not visible`, `-value` |
| 3 | `*`, `/` | Multiplication/Division | `a * b`, `x / y` |
| 4 | `+`, `-` | Addition/Subtraction | `a + b`, `x - y` |
| 5 | `<`, `>`, `<=`, `>=` | Relational comparison | `age >= 18`, `score < 100` |
| 6 | `==`, `!=` | Equality comparison | `name == "admin"`, `id != 0` |
| 7 | `xor` | Logical XOR | `a xor b` |
| 8 | `&&`, `and` | Logical AND | `a && b`, `x and y` |
| 9 | `\|\|`, `or` | Logical OR | `a \|\| b`, `x or y` |

### Variables and Functions
- **Variables**: `x`, `health`, `pos.x`, `player_name`
- **Function calls**: `max(a, b)`, `sqrt(x)`, `distance(x1, y1, x2, y2)`

### Built-in Mathematical Functions
ExpressionKit provides a comprehensive set of standard mathematical functions through the `CallStandardFunctions` method:

| Function | Description | Example |
|----------|-------------|---------|
| `min(a, b)` | Returns the smaller of two numbers | `min(10, 5)` ‚Üí `5` |
| `max(a, b)` | Returns the larger of two numbers | `max(10, 5)` ‚Üí `10` |
| `sqrt(x)` | Returns the square root of x | `sqrt(16)` ‚Üí `4` |
| `sin(x)` | Returns the sine of x (radians) | `sin(3.14159/2)` ‚Üí `1` |
| `cos(x)` | Returns the cosine of x (radians) | `cos(0)` ‚Üí `1` |
| `tan(x)` | Returns the tangent of x (radians) | `tan(0)` ‚Üí `0` |
| `abs(x)` | Returns the absolute value of x | `abs(-5)` ‚Üí `5` |
| `pow(x, y)` | Returns x raised to the power of y | `pow(2, 3)` ‚Üí `8` |
| `log(x)` | Returns the natural logarithm of x | `log(2.718)` ‚Üí `‚âà1` |
| `exp(x)` | Returns e raised to the power of x | `exp(1)` ‚Üí `‚âà2.718` |
| `floor(x)` | Returns the largest integer ‚â§ x | `floor(3.7)` ‚Üí `3` |
| `ceil(x)` | Returns the smallest integer ‚â• x | `ceil(3.2)` ‚Üí `4` |
| `round(x)` | Returns x rounded to nearest integer | `round(3.6)` ‚Üí `4` |

These functions can be used in IBackend implementations to provide mathematical capabilities:

```cpp
class MathBackend : public ExpressionKit::IBackend {
public:
    ExpressionKit::Value Call(const std::string& name, 
                             const std::vector<ExpressionKit::Value>& args) override {
        ExpressionKit::Value result;
        
        // Try standard mathematical functions first
        if (ExpressionKit::ExprTK::CallStandardFunctions(name, args, result)) {
            return result;
        }
        
        // Custom functions...
        throw ExpressionKit::ExprException("Unknown function: " + name);
    }
    
    // ... other methods
};
```
## üèóÔ∏è Architecture Design

### Core Components

1. **Value** - Unified value type supporting numbers and booleans
2. **IBackend** - Interface for variable and function access
3. **ASTNode** - Base class for abstract syntax tree nodes
4. **Parser** - Recursive descent parser
5. **ExprTK** - Main expression utility class
6. **ExpressionKitBridge** - C bridge for Swift integration (located in `Sources/ExpressionKitBridge/`)

### Swift Integration Architecture

ExpressionKit provides seamless Swift integration through a layered architecture:

1. **ExpressionKit.hpp** - Core C++ header-only library
2. **ExpressionKitBridge** - C interface bridge that wraps the C++ code for Swift compatibility
3. **ExpressionKit (Swift)** - Swift wrapper providing idiomatic Swift APIs

```
Swift Code
    ‚Üì
ExpressionKit (Swift Package)
    ‚Üì
ExpressionKitBridge (C Interface)
    ‚Üì
ExpressionKit.hpp (C++ Core)
```

This design ensures:
- **Clean separation**: Each layer has a clear responsibility
- **Swift safety**: The bridge handles C++/Swift interop complexities
- **Performance**: Minimal overhead between layers
- **Maintainability**: Changes to C++ core don't affect Swift API

### IBackend Interface

The IBackend is a core design pattern in ExpressionKit, providing:

```cpp
class IBackend {
public:
    virtual ~IBackend() = default;
    
    // Required: Get variable value
    virtual Value Get(const std::string& name) = 0;
    
    // Required: Call function
    virtual Value Call(const std::string& name, 
                      const std::vector<Value>& args) = 0;
};
```

Advantages of this design:
- **Decoupling**: Separates expression parsing from concrete data sources
- **Flexibility**: Can integrate with any data source (database, config files, game state, etc.)
- **Testability**: Easy to create mock IBackends for different scenarios
- **Performance**: Avoids string lookups, supports direct memory access

## üìä Performance Characteristics

### Benefits of Pre-Parsed AST

1. **Parse once, execute many times**
   ```cpp
   // Slow: parse every time
   for (int i = 0; i < 1000000; ++i) {
       auto result = ExprTK::Eval("complex_expression", &backend);
   }
   
   // Fast: pre-parse and reuse
   auto ast = ExprTK::Parse("complex_expression");
   for (int i = 0; i < 1000000; ++i) {
       auto result = ast->evaluate(&backend);
   }
   ```

2. **Memory efficiency**: AST nodes use shared_ptr for safety and efficiency
3. **Type safety**: Compile-time type checking and runtime validation

## üéØ Use Cases

- **Game engines**: Skill systems, AI condition checks, configuration expressions
- **Configuration systems**: Dynamic rules, conditional logic
- **Business rule engines**: Complex business logic expressions
- **Data processing**: Computed fields, filtering conditions
- **Scripting systems**: Embedded expression evaluation

## üîç Error Handling

ExpressionKit uses exceptions for error handling:

```cpp
try {
    auto result = ExprTK::Eval("invalid expression ++ --", &backend);
} catch (const ExpressionKit::ExprException& e) {
    std::cerr << "Expression error: " << e.what() << std::endl;
}
```

Common error types:
- Syntax errors: Invalid expression syntax
- Type errors: Mismatched operand types
- Runtime errors: Division by zero, undefined variables, etc.
- Function errors: Unknown functions, incorrect arguments

## üöß Compilation Requirements

- C++11 or later
- Only depends on the C++ standard library

## üìö More Examples

See the `test.cpp` file for additional usage examples and test cases.

## ü§ù Contributing

As this project is primarily AI-generated, for suggested changes:
1. Provide specific feature requirements
2. Describe the desired API design
3. Include test cases

## üìû Support

For questions or suggestions, please open an Issue or review the code comments for implementation details.

---

# ExpressionKit

‰∏Ä‰∏™ËΩªÈáèÁ∫ß„ÄÅÊé•Âè£È©±Âä®ÁöÑC++Ë°®ËææÂºèËß£Êûê‰∏éÊ±ÇÂÄºÂ∫ì

## üöÄ ‰∏ªË¶ÅÁâπÊÄß

- **Êé•Âè£ÂåñÂèòÈáèËØªÂÜô**ÔºöÈÄöËøáIBackendÊé•Âè£ÂÆûÁé∞ÂèòÈáèÂíåÂáΩÊï∞ÁöÑÁÅµÊ¥ªËÆøÈóÆ
- **È¢ÑËß£ÊûêASTÊâßË°å**ÔºöÊîØÊåÅË°®ËææÂºèÈ¢ÑÁºñËØëÔºåÂèØÈáçÂ§çÈ´òÊïàÊâßË°å
- **Á±ªÂûãÂÆâÂÖ®**ÔºöÂº∫Á±ªÂûãValueÁ≥ªÁªüÔºåÊîØÊåÅÊï∞ÂÄºÂíåÂ∏ÉÂ∞îÁ±ªÂûã
- **ÂÆåÊï¥ËøêÁÆóÁ¨¶ÊîØÊåÅ**ÔºöÁÆóÊúØ„ÄÅÊØîËæÉ„ÄÅÈÄªËæëËøêÁÆóÁ¨¶ÂÖ®Ë¶ÜÁõñ
- **ÂºÇÂ∏∏ÈîôËØØÂ§ÑÁêÜ**ÔºöÊ∏ÖÊô∞ÁöÑÈîôËØØ‰ø°ÊÅØÂíåÂºÇÂ∏∏Êú∫Âà∂
- **Èõ∂‰æùËµñ**Ôºö‰ªÖ‰æùËµñC++Ê†áÂáÜÂ∫ì

## ü§ñ AIÁîüÊàêÂ£∞Êòé

**ÈáçË¶ÅÊèêÁ§∫ÔºöÊú¨È°πÁõÆ‰ª£Á†Å‰∏ªË¶ÅÁî±AIÔºàGitHub CopilotÁ≠âAIÂ∑•ÂÖ∑ÔºâÁîüÊàêÔºåÁªèËøá‰∫∫Â∑•ÊåáÂØºÂíåÂÆ°Êü•„ÄÇ**

‰ª£Á†ÅÈÅµÂæ™Áé∞‰ª£C++ÊúÄ‰Ω≥ÂÆûË∑µÔºåÊèê‰æõ‰∫Ü‰∏Ä‰∏™Ê∏ÖÊ¥Å„ÄÅÂü∫‰∫éÊé•Âè£ÁöÑË°®ËææÂºèÊ±ÇÂÄºÁ≥ªÁªü„ÄÇ

## üìÑ ËÆ∏ÂèØËØÅ

Êú¨È°πÁõÆÈááÁî®MITËÆ∏ÂèØËØÅ - ËØ¶ËßÅÊñá‰ª∂Â§¥ÈÉ®ÁöÑËÆ∏ÂèØËØÅÂ£∞Êòé„ÄÇ

## üõ†Ô∏è Âø´ÈÄüÂºÄÂßã

### Âü∫Êú¨Áî®Ê≥ï

```cpp
#include "ExpressionKit.hpp"
using namespace ExpressionKit;

// ÁÆÄÂçïÁöÑÊï∞Â≠¶Ë°®ËææÂºèÊ±ÇÂÄº
auto result = ExprTK::Eval("2 + 3 * 4");  // ËøîÂõû 14.0
std::cout << "ÁªìÊûú: " << result.asNumber() << std::endl;

// Â∏ÉÂ∞îË°®ËææÂºè
auto boolResult = ExprTK::Eval("true && false");  // ËøîÂõû false
std::cout << "Â∏ÉÂ∞îÁªìÊûú: " << boolResult.asBoolean() << std::endl;
```

### ‰ΩøÁî®IBackendÂÆûÁé∞ÂèòÈáèËÆøÈóÆ

```cpp
#include "ExpressionKit.hpp"
#include <unordered_map>

class GameBackend : public ExpressionKit::IBackend {
private:
    std::unordered_map<std::string, ExpressionKit::Value> variables;
    
public:
    GameBackend() {
        // ÂàùÂßãÂåñÊ∏∏ÊàèÁä∂ÊÄÅ
        variables["health"] = 100.0;
        variables["maxHealth"] = 100.0;
        variables["level"] = 5.0;
        variables["isAlive"] = true;
        variables["pos.x"] = 10.5;
        variables["pos.y"] = 20.3;
    }
    
    // ÂÆûÁé∞ÂèòÈáèËØªÂèñ
    ExpressionKit::Value Get(const std::string& name) override {
        auto it = variables.find(name);
        if (it == variables.end()) {
            throw ExpressionKit::ExprException("Êú™ÊâæÂà∞ÂèòÈáè: " + name);
        }
        return it->second;
    }
    
    // ÂÆûÁé∞ÂáΩÊï∞Ë∞ÉÁî®
    ExpressionKit::Value Call(const std::string& name, 
                             const std::vector<ExpressionKit::Value>& args) override {
        // ÂÖàÂ∞ùËØïÊ†áÂáÜÊï∞Â≠¶ÂáΩÊï∞
        ExpressionKit::Value result;
        if (ExpressionKit::ExprTK::CallStandardFunctions(name, args, result)) {
            return result;
        }
        
        // Ëá™ÂÆö‰πâÂáΩÊï∞
        if (name == "distance" && args.size() == 4) {
            double x1 = args[0].asNumber(), y1 = args[1].asNumber();
            double x2 = args[2].asNumber(), y2 = args[3].asNumber();
            double dx = x2 - x1, dy = y2 - y1;
            return ExpressionKit::Value(std::sqrt(dx*dx + dy*dy));
        }
        throw ExpressionKit::ExprException("Êú™Áü•ÂáΩÊï∞: " + name);
    }
};

// ‰ΩøÁî®Á§∫‰æã
int main() {
    GameBackend backend;
    
    // Ê∏∏ÊàèÈÄªËæëË°®ËææÂºè
    auto healthPercent = ExprTK::Eval("health / maxHealth", &backend);
    std::cout << "ÁîüÂëΩÂÄºÁôæÂàÜÊØî: " << healthPercent.asNumber() << std::endl;
    
    // Â§çÊùÇÊù°‰ª∂Âà§Êñ≠
    auto needHealing = ExprTK::Eval("health < maxHealth * 0.5 && isAlive", &backend);
    std::cout << "ÈúÄË¶ÅÊ≤ªÁñó: " << (needHealing.asBoolean() ? "ÊòØ" : "Âê¶") << std::endl;
    
    // ÂáΩÊï∞Ë∞ÉÁî®
    auto playerPos = ExprTK::Eval("distance(pos.x, pos.y, 0, 0)", &backend);
    std::cout << "Ë∑ùÁ¶ªÂéüÁÇπ: " << playerPos.asNumber() << std::endl;
    
    return 0;
}
```

### È¢ÑËß£ÊûêASTÈ´òÊÄßËÉΩÊâßË°å

ExpressionKitÁöÑ‰∏Ä‰∏™ÂÖ≥ÈîÆÁâπÊÄßÊòØÊîØÊåÅ**È¢ÑËß£ÊûêAST**ÔºåËøôÂÖÅËÆ∏‰Ω†Ôºö
1. ‰∏ÄÊ¨°Ëß£ÊûêË°®ËææÂºè
2. Â§öÊ¨°È´òÊïàÊâßË°å
3. ÈÅøÂÖçÈáçÂ§çËß£ÊûêÂºÄÈîÄ

```cpp
#include "ExpressionKit.hpp"

class HighPerformanceExample {
private:
    GameBackend backend;
    // È¢ÑÁºñËØëÁöÑË°®ËææÂºèAST
    std::shared_ptr<ExpressionKit::ASTNode> healthCheckExpr;
    std::shared_ptr<ExpressionKit::ASTNode> damageCalcExpr;
    std::shared_ptr<ExpressionKit::ASTNode> levelUpExpr;
    
public:
    HighPerformanceExample() {
        // Ê∏∏ÊàèÂêØÂä®Êó∂È¢ÑÁºñËØëÊâÄÊúâË°®ËææÂºè
        healthCheckExpr = ExprTK::Parse("health > 0 && health <= maxHealth");
        damageCalcExpr = ExprTK::Parse("max(0, damage - armor) * (1.0 + level * 0.1)");
        levelUpExpr = ExprTK::Parse("exp >= level * 100");
    }
    
    // Ê∏∏ÊàèÂæ™ÁéØ‰∏≠È´òÊïàÊâßË°å
    void gameLoop() {
        for (int frame = 0; frame < 10000; ++frame) {
            // ÊØèÂ∏ßÈÉΩÊâßË°åÔºå‰ΩÜ‰∏çÈúÄË¶ÅÈáçÊñ∞Ëß£Êûê
            bool playerAlive = healthCheckExpr->evaluate(&backend).asBoolean();
            
            if (playerAlive) {
                // ËÆ°ÁÆó‰º§ÂÆ≥ÔºàÂÅáËÆæËÆæÁΩÆ‰∫ÜdamageÂíåarmorÂèòÈáèÔºâ
                double finalDamage = damageCalcExpr->evaluate(&backend).asNumber();
                
                // Ê£ÄÊü•ÂçáÁ∫ß
                bool canLevelUp = levelUpExpr->evaluate(&backend).asBoolean();
                
                // Ê∏∏ÊàèÈÄªËæë...
            }
        }
    }
};
```

## üîß ÊîØÊåÅÁöÑËØ≠Ê≥ï

### Êï∞ÊçÆÁ±ªÂûã
- **Êï∞ÂÄº**: `42`, `3.14`, `-2.5`
- **Â∏ÉÂ∞îÂÄº**: `true`, `false`

### ËøêÁÆóÁ¨¶ÔºàÊåâ‰ºòÂÖàÁ∫ßÊéíÂ∫èÔºâ

| ‰ºòÂÖàÁ∫ß | ËøêÁÆóÁ¨¶ | ËØ¥Êòé | Á§∫‰æã |
|--------|--------|------|------|
| 1 | `()` | Êã¨Âè∑ÂàÜÁªÑ | `(a + b) * c` |
| 2 | `!`, `not`, `-` | ‰∏ÄÂÖÉËøêÁÆóÁ¨¶ | `!flag`, `not visible`, `-value` |
| 3 | `*`, `/` | ‰πòÈô§ËøêÁÆó | `a * b`, `x / y` |
| 4 | `+`, `-` | Âä†ÂáèËøêÁÆó | `a + b`, `x - y` |
| 5 | `<`, `>`, `<=`, `>=` | ÂÖ≥Á≥ªÊØîËæÉ | `age >= 18`, `score < 100` |
| 6 | `==`, `!=` | Áõ∏Á≠âÊØîËæÉ | `name == "admin"`, `id != 0` |
| 7 | `xor` | ÈÄªËæëÂºÇÊàñ | `a xor b` |
| 8 | `&&`, `and` | ÈÄªËæë‰∏é | `a && b`, `x and y` |
| 9 | `\|\|`, `or` | ÈÄªËæëÊàñ | `a \|\| b`, `x or y` |

### ÂèòÈáèÂíåÂáΩÊï∞
- **ÂèòÈáè**: `x`, `health`, `pos.x`, `player_name`
- **ÂáΩÊï∞Ë∞ÉÁî®**: `max(a, b)`, `sqrt(x)`, `distance(x1, y1, x2, y2)`

### ÂÜÖÁΩÆÊï∞Â≠¶ÂáΩÊï∞
ExpressionKitÈÄöËøá`CallStandardFunctions`ÊñπÊ≥ïÊèê‰æõ‰∫Ü‰∏ÄÂ•óÂÆåÊï¥ÁöÑÊ†áÂáÜÊï∞Â≠¶ÂáΩÊï∞Ôºö

| ÂáΩÊï∞ | ËØ¥Êòé | Á§∫‰æã |
|------|------|------|
| `min(a, b)` | ËøîÂõû‰∏§‰∏™Êï∞‰∏≠ÁöÑËæÉÂ∞èÂÄº | `min(10, 5)` ‚Üí `5` |
| `max(a, b)` | ËøîÂõû‰∏§‰∏™Êï∞‰∏≠ÁöÑËæÉÂ§ßÂÄº | `max(10, 5)` ‚Üí `10` |
| `sqrt(x)` | ËøîÂõûxÁöÑÂπ≥ÊñπÊ†π | `sqrt(16)` ‚Üí `4` |
| `sin(x)` | ËøîÂõûxÁöÑÊ≠£Âº¶ÂÄºÔºàÂºßÂ∫¶Ôºâ | `sin(3.14159/2)` ‚Üí `1` |
| `cos(x)` | ËøîÂõûxÁöÑ‰ΩôÂº¶ÂÄºÔºàÂºßÂ∫¶Ôºâ | `cos(0)` ‚Üí `1` |
| `tan(x)` | ËøîÂõûxÁöÑÊ≠£ÂàáÂÄºÔºàÂºßÂ∫¶Ôºâ | `tan(0)` ‚Üí `0` |
| `abs(x)` | ËøîÂõûxÁöÑÁªùÂØπÂÄº | `abs(-5)` ‚Üí `5` |
| `pow(x, y)` | ËøîÂõûxÁöÑyÊ¨°ÂπÇ | `pow(2, 3)` ‚Üí `8` |
| `log(x)` | ËøîÂõûxÁöÑËá™ÁÑ∂ÂØπÊï∞ | `log(2.718)` ‚Üí `‚âà1` |
| `exp(x)` | ËøîÂõûeÁöÑxÊ¨°ÂπÇ | `exp(1)` ‚Üí `‚âà2.718` |
| `floor(x)` | ËøîÂõû‰∏çÂ§ß‰∫éxÁöÑÊúÄÂ§ßÊï¥Êï∞ | `floor(3.7)` ‚Üí `3` |
| `ceil(x)` | ËøîÂõû‰∏çÂ∞è‰∫éxÁöÑÊúÄÂ∞èÊï¥Êï∞ | `ceil(3.2)` ‚Üí `4` |
| `round(x)` | ËøîÂõûÂõõËàç‰∫îÂÖ•ÂêéÁöÑÊï¥Êï∞ | `round(3.6)` ‚Üí `4` |

Ëøô‰∫õÂáΩÊï∞ÂèØ‰ª•Âú®IBackendÂÆûÁé∞‰∏≠‰ΩøÁî®Ôºå‰ª•Êèê‰æõÊï∞Â≠¶ËÆ°ÁÆóËÉΩÂäõÔºö

```cpp
class MathBackend : public ExpressionKit::IBackend {
public:
    ExpressionKit::Value Call(const std::string& name, 
                             const std::vector<ExpressionKit::Value>& args) override {
        ExpressionKit::Value result;
        
        // ÂÖàÂ∞ùËØïÊ†áÂáÜÊï∞Â≠¶ÂáΩÊï∞
        if (ExpressionKit::ExprTK::CallStandardFunctions(name, args, result)) {
            return result;
        }
        
        // Ëá™ÂÆö‰πâÂáΩÊï∞...
        throw ExpressionKit::ExprException("Êú™Áü•ÂáΩÊï∞: " + name);
    }
    
    // ... ÂÖ∂‰ªñÊñπÊ≥ï
};
```
## üèóÔ∏è Êû∂ÊûÑËÆæËÆ°

### Ê†∏ÂøÉÁªÑ‰ª∂

1. **Value** - Áªü‰∏ÄÁöÑÂÄºÁ±ªÂûãÔºåÊîØÊåÅÊï∞ÂÄºÂíåÂ∏ÉÂ∞î
2. **IBackend** - ÂèòÈáèÂíåÂáΩÊï∞ËÆøÈóÆÊé•Âè£
3. **ASTNode** - ÊäΩË±°ËØ≠Ê≥ïÊ†ëËäÇÁÇπÂü∫Á±ª
4. **Parser** - ÈÄíÂΩí‰∏ãÈôçËß£ÊûêÂô®
5. **ExprTK** - ‰∏ªË¶ÅÁöÑË°®ËææÂºèÂ∑•ÂÖ∑Á±ª

### IBackendÊé•Âè£

IBackendÊòØExpressionKitÁöÑÊ†∏ÂøÉËÆæËÆ°Ê®°ÂºèÔºåÂÆÉÊèê‰æõ‰∫ÜÔºö

```cpp
class IBackend {
public:
    virtual ~IBackend() = default;
    
    // ÂøÖÈ°ªÂÆûÁé∞ÔºöËé∑ÂèñÂèòÈáèÂÄº
    virtual Value Get(const std::string& name) = 0;
    
    // ÂøÖÈ°ªÂÆûÁé∞ÔºöË∞ÉÁî®ÂáΩÊï∞
    virtual Value Call(const std::string& name, 
                      const std::vector<Value>& args) = 0;
};
```

ËøôÁßçËÆæËÆ°ÁöÑ‰ºòÂäøÔºö
- **Ëß£ËÄ¶**ÔºöË°®ËææÂºèËß£Êûê‰∏éÂÖ∑‰ΩìÊï∞ÊçÆÊ∫êÂàÜÁ¶ª
- **ÁÅµÊ¥ª**ÔºöÂèØ‰ª•Êé•ÂÖ•‰ªª‰ΩïÊï∞ÊçÆÊ∫êÔºàÊï∞ÊçÆÂ∫ì„ÄÅÈÖçÁΩÆÊñá‰ª∂„ÄÅÊ∏∏ÊàèÁä∂ÊÄÅÁ≠âÔºâ
- **ÂèØÊµãËØï**ÔºöÊòì‰∫é‰∏∫‰∏çÂêåÂú∫ÊôØÂàõÂª∫Mock IBackend
- **È´òÊÄßËÉΩ**ÔºöÈÅøÂÖçÂ≠óÁ¨¶‰∏≤Êü•ÊâæÔºåÊîØÊåÅÁõ¥Êé•ÂÜÖÂ≠òËÆøÈóÆ

## üìä ÊÄßËÉΩÁâπÊÄß

### È¢ÑËß£ÊûêASTÁöÑ‰ºòÂäø

1. **‰∏ÄÊ¨°Ëß£ÊûêÔºåÂ§öÊ¨°ÊâßË°å**
   ```cpp
   // ÊÖ¢ÔºöÊØèÊ¨°ÈÉΩËß£Êûê
   for (int i = 0; i < 1000000; ++i) {
       auto result = ExprTK::Eval("complex_expression", &backend);
   }
   
   // Âø´ÔºöÈ¢ÑËß£ÊûêÂêéÈáçÂ§çÊâßË°å
   auto ast = ExprTK::Parse("complex_expression");
   for (int i = 0; i < 1000000; ++i) {
       auto result = ast->evaluate(&backend);
   }
   ```

2. **ÂÜÖÂ≠òÊïàÁéá**: ASTËäÇÁÇπ‰ΩøÁî®shared_ptrÔºåÂÆâÂÖ®‰∏îÈ´òÊïà
3. **Á±ªÂûãÂÆâÂÖ®**: ÁºñËØëÊó∂Á±ªÂûãÊ£ÄÊü•ÔºåËøêË°åÊó∂Á±ªÂûãÈ™åËØÅ

## üéØ ‰ΩøÁî®Âú∫ÊôØ

- **Ê∏∏ÊàèÂºïÊìé**: ÊäÄËÉΩÁ≥ªÁªü„ÄÅAIÊù°‰ª∂Âà§Êñ≠„ÄÅÈÖçÁΩÆË°®ËææÂºè
- **ÈÖçÁΩÆÁ≥ªÁªü**: Âä®ÊÄÅÈÖçÁΩÆËßÑÂàô„ÄÅÊù°‰ª∂Âà§Êñ≠
- **‰∏öÂä°ËßÑÂàôÂºïÊìé**: Â§çÊùÇ‰∏öÂä°ÈÄªËæëË°®ËææÂºè
- **Êï∞ÊçÆÂ§ÑÁêÜ**: ËÆ°ÁÆóÂ≠óÊÆµ„ÄÅËøáÊª§Êù°‰ª∂
- **ËÑöÊú¨Á≥ªÁªü**: ÂµåÂÖ•ÂºèË°®ËææÂºèÊ±ÇÂÄº

## üîç ÈîôËØØÂ§ÑÁêÜ

ExpressionKit‰ΩøÁî®ÂºÇÂ∏∏Êú∫Âà∂Â§ÑÁêÜÈîôËØØÔºö

```cpp
try {
    auto result = ExprTK::Eval("invalid expression ++ --", &backend);
} catch (const ExpressionKit::ExprException& e) {
    std::cerr << "Ë°®ËææÂºèÈîôËØØ: " << e.what() << std::endl;
}
```

Â∏∏ËßÅÈîôËØØÁ±ªÂûãÔºö
- ËØ≠Ê≥ïÈîôËØØÔºöÊó†ÊïàÁöÑË°®ËææÂºèËØ≠Ê≥ï
- Á±ªÂûãÈîôËØØÔºöÁ±ªÂûã‰∏çÂåπÈÖçÁöÑÊìç‰Ωú
- ËøêË°åÊó∂ÈîôËØØÔºöÈô§Èõ∂„ÄÅÊú™ÂÆö‰πâÂèòÈáèÁ≠â
- ÂáΩÊï∞ÈîôËØØÔºöÊú™Áü•ÂáΩÊï∞„ÄÅÂèÇÊï∞‰∏çÂåπÈÖç

## üöß ÁºñËØëË¶ÅÊ±Ç

- C++11 ÊàñÊõ¥È´òÁâàÊú¨
- ‰ªÖ‰æùËµñC++Ê†áÂáÜÂ∫ì

## üìö Êõ¥Â§öÁ§∫‰æã

Êü•Áúã `test.cpp` Êñá‰ª∂‰ª•Ëé∑ÂèñÊõ¥Â§ö‰ΩøÁî®Á§∫‰æãÂíåÊµãËØïÁî®‰æã„ÄÇ

## ü§ù Ë¥°ÁåÆ

Áî±‰∫éÊú¨È°πÁõÆ‰∏ªË¶ÅÁî±AIÁîüÊàêÔºåÂ¶ÇÈúÄ‰øÆÊîπÂª∫ËÆÆÔºö
1. ÊèêÂá∫ÂÖ∑‰ΩìÁöÑÂäüËÉΩÈúÄÊ±Ç
2. ÊèèËø∞È¢ÑÊúüÁöÑAPIËÆæËÆ°
3. Êèê‰æõÊµãËØïÁî®‰æã

## üìû ÊîØÊåÅ

Â¶ÇÊúâÈóÆÈ¢òÊàñÂª∫ËÆÆÔºåËØ∑ÂàõÂª∫IssueÊàñÊü•Áúã‰ª£Á†ÅÊ≥®Èáä‰ª•‰∫ÜËß£ÂÆûÁé∞ÁªÜËäÇ„ÄÇ
