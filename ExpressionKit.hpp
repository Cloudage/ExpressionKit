/*
 * MIT License
 *
 * Copyright (c) 2025 ExpressionKit Contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * NOTE: This code is primarily generated by AI (GitHub Copilot and Claude Sonnet 4)
 * with human guidance and review. The implementation follows modern C++ best
 * practices and provides a clean, interface-based expression evaluation system.
 */

/**
 * @file ExpressionKit.hpp
 * @brief A lightweight, interface-driven expression parser and evaluator for C++
 * @version 1.0.0
 * @date 2025-07-24
 *
 * ExpressionKit provides a clean and extensible way to parse and evaluate mathematical
 * and logical expressions. Key features include:
 *
 * - Interface-based variable and function access through Backend abstraction
 * - Pre-parsed AST support for efficient repeated evaluation
 * - Support for numbers, booleans, variables, and function calls
 * - Comprehensive operator support (arithmetic, comparison, logical)
 * - Type-safe value system with automatic conversions
 * - Exception-based error handling
 *
 * The library is designed to be embedded in larger applications where expressions
 * need to be evaluated against dynamic data sources.
 */

#ifndef EXPRESSION_KIT_HPP
#define EXPRESSION_KIT_HPP

#include <string>
#include <memory>
#include <stdexcept>
#include <vector>
#include <iostream>

namespace ExpressionKit {

    // Forward declarations for internal use
    class ASTNode;
    using ASTNodePtr = std::shared_ptr<ASTNode>;

    /**
     * @brief Exception type for expression parsing and evaluation errors
     *
     * This exception is thrown when expression syntax is invalid or
     * when runtime evaluation fails (e.g., division by zero, undefined variables).
     */
    class ExprException final : public std::runtime_error {
    public:
        explicit ExprException(const std::string& msg) : std::runtime_error(msg) {}
    };

    /**
     * @brief Value type that can hold either a number or boolean
     *
     * This is the fundamental data type used throughout the expression system.
     * It supports automatic conversion from common C++ types and provides
     * type-safe access methods.
     */
    struct Value {
        enum Type { NUMBER, BOOLEAN } type;
        union {
            double number = 0;
            bool boolean;
        } data;

        /**
         * @brief Default constructor - creates a number value of 0.0
         */
        Value() : type(NUMBER) { data.number = 0.0; }

        /**
         * @brief Construct from double value
         * @param n The number value
         */
        Value(const double n) : type(NUMBER) { data.number = n; }

        /**
         * @brief Construct from float value (converted to double)
         * @param n The number value
         */
        Value(const float n) : type(NUMBER) { data.number = static_cast<double>(n); }

        /**
         * @brief Construct from int value (converted to double)
         * @param n The number value
         */
        Value(const int n) : type(NUMBER) { data.number = static_cast<double>(n); }

        /**
         * @brief Construct from boolean value
         * @param b The boolean value
         */
        Value(const bool b) : type(BOOLEAN) { data.boolean = b; }

        /**
         * @brief Check if this value is a number
         * @return true if the value contains a number, false otherwise
         */
        bool isNumber() const { return type == NUMBER; }

        /**
         * @brief Check if this value is a boolean
         * @return true if the value contains a boolean, false otherwise
         */
        bool isBoolean() const { return type == BOOLEAN; }

        /**
         * @brief Get the number value
         * @return The number value
         * @throws ExprException if the value is not a number
         */
        double asNumber() const {
            if (!isNumber()) throw ExprException("类型错误：期望数值类型");
            return data.number;
        }

        /**
         * @brief Get the boolean value
         * @return The boolean value
         * @throws ExprException if the value is not a boolean
         */
        bool asBoolean() const {
            if (!isBoolean()) throw ExprException("类型错误：期望布尔类型");
            return data.boolean;
        }

        /**
         * @brief Convert value to string representation
         * @return String representation of the value
         */
        std::string toString() const {
            if (isNumber()) return std::to_string(data.number);
            return data.boolean ? "true" : "false";
        }
    };

    /**
     * @brief Backend interface for variable access and function calls
     *
     * Implement this interface to provide custom variable storage and function
     * implementations. The backend is responsible for handling variable reads,
     * optional variable writes, and function calls during expression evaluation.
     *
     * @note The integrating application is responsible for managing the backend's
     *       lifetime. ExprTK stores only a raw pointer and does not take ownership.
     */
    class IBackend {
        protected: IBackend() = default;

    public:
        virtual ~IBackend() = default;

        /**
         * @brief Get a variable value by name
         * @param name Variable name (supports dot notation like "pos.x")
         * @return The variable value
         * @throws ExprException if the variable is not found
         */
        virtual Value Get(const std::string& name) = 0;

        /**
         * @brief Call a function with given arguments
         * @param name Function name
         * @param args Function arguments
         * @return Function result
         * @throws ExprException if the function is not found or arguments are invalid
         */
        virtual Value Call(const std::string& name, const std::vector<Value>& args) = 0;
    };

    /**
     * @brief Abstract base class for all AST (Abstract Syntax Tree) nodes
     *
     * This is the foundation of the expression evaluation system. Every element
     * in an expression (numbers, variables, operators, functions) is represented
     * as an AST node that can be evaluated against a backend.
     *
     * @note This is an internal implementation detail. Users typically work
     *       with compiled expressions through the ExprTK interface.
     */
    class ASTNode {
    public:
        virtual ~ASTNode() = default;

        /**
         * @brief Evaluate this node and return its value
         * @param backend Backend for variable and function resolution (can be null for constants)
         * @return The computed value of this node
         * @throws ExprException If evaluation fails
         */
        virtual Value evaluate(IBackend* backend) const = 0;
    };

    /**
     * @brief AST node representing a numeric literal
     *
     * This node holds a constant numeric value and returns it during evaluation.
     * Examples: 42, 3.14, -2.5
     */
    class NumberNode final : public ASTNode {
        double value;
    public:
        explicit NumberNode(const double v) : value(v) {}
        Value evaluate(IBackend*) const override {
            return Value(value);
        }
    };

    /**
     * @brief AST node representing a boolean literal
     *
     * This node holds a constant boolean value and returns it during evaluation.
     * Examples: true, false
     */
    class BooleanNode final : public ASTNode {
        bool value;
    public:
        explicit BooleanNode(const bool v) : value(v) {}
        Value evaluate(IBackend*) const override {
            return Value(value);
        }
    };

    /**
     * @brief AST node representing a variable reference
     *
     * This node stores a variable name and delegates to the IBackend during
     * evaluation to resolve the variable's current value.
     * Examples: x, pos.x, player_health
     */
    class VariableNode final : public ASTNode {
        std::string name;
    public:
        explicit VariableNode(const std::string& n) : name(n) {}
        Value evaluate(IBackend* backend) const override {
            if (!backend) throw ExprException("变量访问需要 IBackend");
            return backend->Get(name);
        }
    };

    /**
     * @brief Enumeration of all supported operators
     *
     * This enum defines all arithmetic, comparison, and logical operators
     * supported by the expression system. Operators are grouped by category
     * for easier understanding and implementation.
     */
    enum class OperatorType {
        ADD, SUB, MUL, DIV,           // 算术运算符: +, -, *, /
        EQ, NE, GT, LT, GE, LE,       // 比较运算符: ==, !=, >, <, >=, <=
        AND, OR, XOR, NOT             // 逻辑运算符: &&, ||, xor, !
    };

    /**
     * @brief AST node representing binary operations (operations with two operands)
     *
     * This node handles all binary operators including arithmetic, comparison,
     * and logical operations. It evaluates both operands and applies the
     * specified operator according to type compatibility rules.
     *
     * Supported operations:
     * - Arithmetic: 2 + 3, 5 * 4, 10 / 2, 7 - 1
     * - Comparison: x == 5, age >= 18, score != 0
     * - Logical: a && b, x || y, p xor q
     */
    class BinaryOpNode final : public ASTNode {
        ASTNodePtr left, right;
        OperatorType op;
    public:
        BinaryOpNode(ASTNodePtr l, const OperatorType o, ASTNodePtr r)
            : left(std::move(l)), right(std::move(r)), op(o) {}

        Value evaluate(IBackend* backend) const override {
            const Value lhs = left->evaluate(backend);

            // 数值运算
            if (const Value rhs = right->evaluate(backend); lhs.isNumber() && rhs.isNumber()) {
                const double a = lhs.asNumber();
                const double b = rhs.asNumber();
                switch (op) {
                    case OperatorType::ADD: return Value(a + b);
                    case OperatorType::SUB: return Value(a - b);
                    case OperatorType::MUL: return Value(a * b);
                    case OperatorType::DIV:
                        if (b == 0) throw ExprException("除零错误");
                        return Value(a / b);
                    case OperatorType::GT: return Value(a > b);
                    case OperatorType::LT: return Value(a < b);
                    case OperatorType::GE: return Value(a >= b);
                    case OperatorType::LE: return Value(a <= b);
                    case OperatorType::EQ: return Value(a == b);
                    case OperatorType::NE: return Value(a != b);
                    default:
                        throw ExprException("不支持的数值运算符");
                }
            }
            // 布尔运算
            else if (lhs.isBoolean() && rhs.isBoolean()) {
                const bool a = lhs.asBoolean();
                const bool b = rhs.asBoolean();
                switch (op) {
                    case OperatorType::AND: return Value(a && b);
                    case OperatorType::OR: return Value(a || b);
                    case OperatorType::XOR: return Value(a != b); // XOR 是异或
                    case OperatorType::EQ: return Value(a == b);
                    case OperatorType::NE: return Value(a != b);
                    default:
                        throw ExprException("不支持的布尔运算符");
                }
            }

            throw ExprException("不支持的操作数类型");
        }
    };

    /**
     * @brief AST node representing unary operations (operations with one operand)
     *
     * This node handles unary operators that operate on a single value:
     * - Logical NOT: !condition, not flag
     * - Arithmetic negation: -number, -expression
     *
     * Examples: !true, -42, -(x + y), not visible
     */
    class UnaryOpNode final : public ASTNode {
        ASTNodePtr operand;
        OperatorType op;
    public:
        UnaryOpNode(const OperatorType o, ASTNodePtr operand)
            : operand(std::move(operand)), op(o) {}

        Value evaluate(IBackend* backend) const override {
            const Value val = operand->evaluate(backend);

            switch (op) {
                case OperatorType::NOT:
                    if (!val.isBoolean()) throw ExprException("NOT 运算符只能用于布尔值");
                    return Value(!val.asBoolean());
                case OperatorType::SUB: // 负号
                    if (!val.isNumber()) throw ExprException("负号只能用于数值");
                    return Value(-val.asNumber());
                default:
                    throw ExprException("不支持的一元运算符");
            }
        }
    };

    /**
     * @brief AST node representing function calls
     *
     * This node stores a function name and a list of argument expressions.
     * During evaluation, it evaluates all arguments and delegates to the
     * IBackend to perform the actual function Call.
     *
     * Examples: max(a, b), sqrt(x), distance(x1, y1, x2, y2)
     */
    class FunctionCallNode final : public ASTNode {
        std::string name;
        std::vector<ASTNodePtr> args;
    public:
        FunctionCallNode(const std::string& n, std::vector<ASTNodePtr> a)
            : name(n), args(std::move(a)) {}

        Value evaluate(IBackend* backend) const override {
            if (!backend) throw ExprException("函数调用需要 IBackend");
            std::vector<Value> evaluatedArgs;
            for (const auto& arg : args) {
                evaluatedArgs.push_back(arg->evaluate(backend));
            }
            return backend->Call(name, evaluatedArgs);
        }
    };

    /**
     * @brief Recursive descent parser for expression strings
     *
     * This class implements a complete expression parser using the recursive
     * descent parsing technique. It supports operator precedence, associativity,
     * and proper error reporting.
     *
     * Grammar (in order of precedence, highest to lowest):
     * - Primary: numbers, booleans, variables, function calls, parentheses
     * - Unary: !, not, - (unary minus)
     * - Multiplicative: *, /
     * - Additive: +, -
     * - Relational: <, >, <=, >=
     * - Equality: ==, !=
     * - Logical XOR: xor
     * - Logical AND: &&, and
     * - Logical OR: ||, or
     *
     * The parser is designed to be used once per expression string and
     * produces an AST that can be evaluated multiple times efficiently.
     */
    class Parser {
        std::string expr;
        size_t pos = 0;

        void skipWhitespace() {
            while (pos < expr.size() && std::isspace(expr[pos])) ++pos;
        }

        bool match(const std::string& str) {
            skipWhitespace();
            if (pos + str.length() <= expr.size() &&
                expr.substr(pos, str.length()) == str) {
                pos += str.length();
                return true;
            }
            return false;
        }

        bool match(const char c) {
            skipWhitespace();
            if (pos < expr.size() && expr[pos] == c) {
                ++pos;
                return true;
            }
            return false;
        }

        char peek() {
            skipWhitespace();
            if (pos >= expr.size()) return '\0';
            return expr[pos];
        }

        std::string peekString(const size_t len) {
            skipWhitespace();
            if (pos + len > expr.size()) return "";
            return expr.substr(pos, len);
        }

        char consume() {
            skipWhitespace();
            if (pos >= expr.size()) throw ExprException("意外的表达式结尾");
            return expr[pos++];
        }

        // 解析逻辑表达式（最低优先级）
        ASTNodePtr parseOrExpression() {
            auto left = parseAndExpression();
            while (match("||") || match("or")) {
                auto right = parseAndExpression();
                left = std::make_shared<BinaryOpNode>(left, OperatorType::OR, right);
            }
            return left;
        }

        // 解析与表达式
        ASTNodePtr parseAndExpression() {
            auto left = parseXorExpression();
            while (match("&&") || match("and")) {
                auto right = parseXorExpression();
                left = std::make_shared<BinaryOpNode>(left, OperatorType::AND, right);
            }
            return left;
        }

        // 解析异或表达式
        ASTNodePtr parseXorExpression() {
            auto left = parseEqualityExpression();
            while (match("xor")) {
                auto right = parseEqualityExpression();
                left = std::make_shared<BinaryOpNode>(left, OperatorType::XOR, right);
            }
            return left;
        }

        // 解析相等性表达式
        ASTNodePtr parseEqualityExpression() {
            auto left = parseRelationalExpression();
            while (true) {
                if (match("==")) {
                    auto right = parseRelationalExpression();
                    left = std::make_shared<BinaryOpNode>(left, OperatorType::EQ, right);
                } else if (match("!=")) {
                    auto right = parseRelationalExpression();
                    left = std::make_shared<BinaryOpNode>(left, OperatorType::NE, right);
                } else {
                    break;
                }
            }
            return left;
        }

        // 解析关系表达式
        ASTNodePtr parseRelationalExpression() {
            auto left = parseAdditiveExpression();
            while (true) {
                if (match(">=")) {
                    auto right = parseAdditiveExpression();
                    left = std::make_shared<BinaryOpNode>(left, OperatorType::GE, right);
                } else if (match("<=")) {
                    auto right = parseAdditiveExpression();
                    left = std::make_shared<BinaryOpNode>(left, OperatorType::LE, right);
                } else if (match(">")) {
                    auto right = parseAdditiveExpression();
                    left = std::make_shared<BinaryOpNode>(left, OperatorType::GT, right);
                } else if (match("<")) {
                    auto right = parseAdditiveExpression();
                    left = std::make_shared<BinaryOpNode>(left, OperatorType::LT, right);
                } else {
                    break;
                }
            }
            return left;
        }

        // 解析加减表达式
        ASTNodePtr parseAdditiveExpression() {
            auto left = parseMultiplicativeExpression();
            while (peek() == '+' || peek() == '-') {
                const char op = consume();
                auto right = parseMultiplicativeExpression();
                OperatorType opType = (op == '+') ? OperatorType::ADD : OperatorType::SUB;
                left = std::make_shared<BinaryOpNode>(left, opType, right);
            }
            return left;
        }

        // 解析乘除表达式
        ASTNodePtr parseMultiplicativeExpression() {
            auto left = parseUnaryExpression();
            while (peek() == '*' || peek() == '/') {
                const char op = consume();
                auto right = parseUnaryExpression();
                OperatorType opType = (op == '*') ? OperatorType::MUL : OperatorType::DIV;
                left = std::make_shared<BinaryOpNode>(left, opType, right);
            }
            return left;
        }

        // 解析一元表达式
        ASTNodePtr parseUnaryExpression() {
            if (match("!") || match("not")) {
                auto operand = parseUnaryExpression();
                return std::make_shared<UnaryOpNode>(OperatorType::NOT, operand);
            }

            if (match("-")) {
                auto operand = parseUnaryExpression();
                return std::make_shared<UnaryOpNode>(OperatorType::SUB, operand);
            }

            return parsePrimaryExpression();
        }

        // 解析基本表达式
        ASTNodePtr parsePrimaryExpression() {
            if (match('(')) {
                auto expr = parseOrExpression();
                if (!match(')')) throw ExprException("缺少右括号");
                return expr;
            }

            if (std::isdigit(peek()) || peek() == '.') {
                std::string num;
                while (pos < expr.size() && (std::isdigit(expr[pos]) || expr[pos] == '.')) {
                    num += expr[pos++];
                }
                return std::make_shared<NumberNode>(std::stod(num));
            }

            if (std::isalpha(peek())) {
                std::string ident;
                while (pos < expr.size() && (std::isalnum(expr[pos]) || expr[pos] == '.' || expr[pos] == '_')) {
                    ident += expr[pos++];
                }

                if (match('(')) {
                    std::vector<ASTNodePtr> args;
                    if (!match(')')) {
                        do {
                            args.push_back(parseOrExpression());
                        } while (match(','));
                        if (!match(')')) throw ExprException("函数调用缺少右括号");
                    }
                    return std::make_shared<FunctionCallNode>(ident, args);
                }

                if (ident == "true") return std::make_shared<BooleanNode>(true);
                if (ident == "false") return std::make_shared<BooleanNode>(false);

                return std::make_shared<VariableNode>(ident);
            }

            throw ExprException("无法识别的表达式");
        }

    public:
        explicit Parser(const std::string& expression) : expr(expression) {}

        ASTNodePtr parse() {
            pos = 0;
            auto result = parseOrExpression();
            skipWhitespace();
            if (pos < expr.size()) throw ExprException("表达式解析不完整");
            return result;
        }
    };

    /**
     * @brief Main expression toolkit class for parsing and evaluating expressions
     *
     * ExprTK provides a complete expression evaluation system with support for:
     * - Arithmetic operations (+, -, *, /)
     * - Comparison operations (==, !=, <, >, <=, >=)
     * - Logical operations (&&, ||, !, xor)
     * - Variables and functions via Backend interface
     * - Expression compilation and caching for better performance
     *
     * Usage examples:
     * @code
     * ExprTK exprtk;
     *
     * // Simple evaluation without variables
     * auto result = exprtk.Eval("2 + 3 * 4"); // Returns 14.0
     *
     * // With backend for variables and functions
     * MyBackend backend;
     * exprtk.SetBackend(&backend);
     * auto result2 = exprtk.Eval("x + sqrt(y)");
     *
     * // Compile once, execute multiple times
     * auto compiled = exprtk.Compile("health > maxHealth * 0.5");
     * for (int frame = 0; frame < 100; ++frame) {
     *     auto alive = exprtk.Execute(compiled);
     *     // ... game logic
     * }
     * @endcode
     *
     * @note The ExprTK instance does not own the Backend object. The caller is
     *       responsible for ensuring the Backend remains valid during expression
     *       evaluation.
     */
    class ExprTK {
    public:
        /**
         * @brief Evaluate an expression string directly
         * @param expression The expression string to evaluate
         * @param backend Optional backend for variable and function resolution
         * @return The evaluation result
         * @throws ExprException If parsing fails or evaluation encounters an error
         *
         * This method parses and evaluates the expression in one Call. For
         * expressions that will be evaluated multiple times, consider using
         * Compile() and Execute() for better performance.
         *
         * Supported syntax:
         * - Numbers: 42, 3.14, -2.5
         * - Booleans: true, false
         * - Arithmetic: +, -, *, /
         * - Comparison: ==, !=, <, >, <=, >=
         * - Logical: &&, ||, !, and, or, not, xor
         * - Parentheses for grouping: (expr)
         * - Variables: x, pos.x, player_health
         * - Functions: max(a, b), sqrt(x)
         */
        static Value Eval(const std::string& expression, IBackend* backend = nullptr) {
            return Parse(expression)->evaluate(backend);
        }

        /**
         * @brief Parse an expression string into an Abstract Syntax Tree
         * @param expression The expression string to parse
         * @return The root AST node
         * @throws ExprException If the expression syntax is invalid
         *
         * This method is primarily for internal use. Most users should use
         * Eval() for direct evaluation or Compile() for cached expressions.
         */
        static ASTNodePtr Parse(const std::string& expression) {
            Parser parser(expression);
            return parser.parse();
        }
    };

} // namespace exprtk

#endif // EXPRESSION_KIT_HPP
